---
title: Manipulating columns
---

::: {.callout-tip}
#### Learning objectives

- Learn how to select and/or rename specific columns from a data frame.
- Be able to create new columns and modify existing ones.
:::


## Context

In the [tabular data](#tabular-data) section we learned to deal with, well, tabular data in the form of our `surveys` data set. This data set isn't huge, but sometimes we have many variables and we might only want to work with a subset of them. Or, we might want to create new columns based on existing data. In this section we'll cover how we can do this.

## Section setup {#setup_plotting}

::: {.panel-tabset group="language"}
## R

We'll continue this section with the script named `r paste0(intToUtf8(96), sub("\\..*$", ".R", knitr::current_input()), intToUtf8(96))`. If needed, add the following code to the top of your script and run it.

```{r}
#| message: false
# A collection of R packages designed for data science
library(tidyverse)

surveys <- read_csv("data/surveys.csv")
```

## Python

We'll continue this section with the Notebook named `r paste0(intToUtf8(96), sub("\\..*$", ".ipynb", knitr::current_input()), intToUtf8(96))`. Add the following code to the first cell and run it.

```{python}
# A Python data analysis and manipulation tool
import pandas as pd

# Python equivalent of `ggplot2`
from plotnine import *

surveys = pd.read_csv("data/surveys.csv")
```

:::

## Selecting columns

Let's remind ourselves to which columns we have in our `surveys` data set. After that, we'll start making some changes.

::: {.panel-tabset group="language"}
## R

```{r}
colnames(surveys)
```
 
## Python

```{python}
surveys.columns
```

:::

### Selecting individual columns

Let's say we wanted to select only the `record_id` and `year` columns. We've briefly done this when we looked at [subsetting rows and columns](#subset_rc).

::: {.panel-tabset group="language"}
## R

However, there is an alternative way of doing this using the `dplyr` package - which is part of `tidyverse`.
 
 We can use the `select()` function:
 
```{r}
select(surveys, record_id, year)
```
 
Using the base R syntax, this is equivalent to `surveys[, c("record_id", "year")]`. Notice that with the `select()` function (and generally with `dplyr` functions) we didnâ€™t need to quote " the column names. This is because the first input to the function is the table name, and so everything after is assumed to be column names of that table.

## Python

The way we need to specify this is by giving a list of column names `["record_id", "year"]` and subsetting the surveys data set with this.

The way we subset is with `surveys[ ]`, so we end up with double square brackets:

```{python}
surveys[["record_id", "year"]]
```

:::

### Selecting with helper functions

::: {.panel-tabset group="language"}
## R

The `select()` function becomes particularly useful when we combine it with other helper functions. For example, this code will select all the columns where the column name contains the string (text) `"_id"`:

```{r}
# returns all columns where the column name contains the text "_id"
select(surveys, contains("_id"))
```

Another thing we often want to do is select columns by their data type. For example, if we wanted to select all numerical columns we could do this:

```{r}
select(surveys, where(is.numeric))
```

## Python

The subsetting becomes a bit tedious when we're looking for patterns in the column names. Here, we can instead use the `.filter` attribute of the surveys data set, and look for a string (text) where the column name contains `"_id"`.

```{python}
surveys.filter(like = "_id")
```

Another thing we often want to do is select columns by their data type. For example, if we wanted to select all numerical columns we could do this:

```{python}
surveys.select_dtypes(include = "number")
```

:::

### Selecting a range of columns

Let's say we're interested in all the columns from `record_id` to `year`.

::: {.panel-tabset group="language"}
## R
In that case, we can use the `:` symbol.

```{r}
# returns all columns between and including record_id and year
select(surveys, record_id:year)
```

We can also combine this with the previous method:

```{r}
# returns all columns between and including record_id and year
# and all columns where the column name contains the text "_id"
select(surveys, record_id:year, contains("_id"))
```

## Python

In that case, we can use the `:` symbol, in combination with the `.loc` indexer.

```{python}
surveys.loc[:, "record_id":"year"]
```


:::

### Unselecting columns

Lastly, we can also **unselect columns**. This can be useful when you want most columns, apart from some.

::: {.panel-tabset group="language"}
## R

To do this, we use the `-` symbol before the column name.

```{r}
# returns all columns apart from record_id
select(surveys, -record_id)
```

## Python

To do this, we use the `.drop` attribute. Here, we only unselect one column, but we can easily extend this by providing a list of columns do the `column =` argument.

```{python}
surveys.drop(columns = "record_id")
```

:::

## Renaming and reshuffling columns

### Renaming columns

For example, we might want to change the `weight` column name to `weight_g`, to reflect that the values are in grams.

::: {.panel-tabset group="language"}
## R
We can use the `rename()` function to change a column name. We do this as follows:

```{r}
rename(surveys, weight_g = weight)
```

## Python

We can use the `.rename()` attribute of the `surveys` `pandas` DataFrame:

```{python}
surveys.rename(columns = {'weight': 'weight_g'})
```

:::

### Reshuffling columns

It might be that you want to reorder/reshuffle a column. Here, the `year` column is our fourth variable. Let's say we'd want to  move this to the second position (after `record_id`).

::: {.panel-tabset group="language"}
## R

We can use the `relocate()` function to do this. The function has several arguments, starting with `.`, such as `.before =` or `.after =`. These allow you to specify where you want to reinsert the column.

```{r}
relocate(surveys, year, .after = record_id)
```


## Python

Unlike in R, there isn't a very clear, straightforward way of reinserting columns in a `pandas` DataFrame. We could show you convoluted ways of doing so, but at this point that's just confusing. So, we'll leave you with a [link to a Stackoverflow solution](https://stackoverflow.com/questions/13148429/how-to-change-the-order-of-dataframe-columns).
:::

## Creating new columns

Sometimes we need to create new columns. For example, we might have a variable that is not in the unit of measurement we need (e.g. in millimeters, instead of centimeters).

Conceptually, that looks something like this:

![Creating a new column using data from an existing one.](images/manipulation-new_column.png){#fig-manipulation_new}

Let's illustrate this with an example on our `surveys` data set. Let's say we wanted to get `hindfoot_length` in centimeters, instead of millimeters. We'd have to go through each row, take the `hindfoot_length` value and divide it by 10. We then need to store this output in a column called, for example, `hindfoot_length_cm`.

::: {.panel-tabset group="language"}
## R

We can use the `mutate()` function to create new columns:

```{r}
mutate(surveys, hindfoot_length_cm = hindfoot_length / 10)
```

## Python

We use the square brackets to define the name of the new column, then specify what needs to go in the new column:

```{python}
surveys['hindfoot_length_cm'] = surveys['hindfoot_length'] / 10
```

:::

Although it has created the column, we can't quite see it because we have too many columns. So, let's save the new column to the data set and then select the relevant columns.

::: {.panel-tabset group="language"}
## R

First, we update our data:

```{r}
surveys <- mutate(surveys, hindfoot_length_cm = hindfoot_length / 10)
```

Next, we can select the columns.

```{r}
select(surveys, record_id, hindfoot_length, hindfoot_length_cm)
```

## Python

Our previous step already added the new column to the DataFrame, so we can directly select the relevant columns, by giving a list of the columns we're interested in:

```{python}
surveys[['record_id', 'hindfoot_length', 'hindfoot_length_cm']]

```

:::

We can see that each value in `hindfoot_length_cm` is a tenth of the value of `hindfoot_length`. This is exactly what we expected!

## Exercises

### Selecting columns: `infections` {#sec-exr_selectcols}

::: {.callout-exercise #ex-selectcols}
#### Selecting columns

{{< level 2 >}}

For this exercise we'll be using a new data set, called `infections`. These are synthetic data (see the [script](https://github.com/cambiotraining/data-analysis-in-r-and-python/blob/main/materials/no_render/data-analysis_data_synthesis.qmd) if you would like to know more).

Please do the following:

1. Read in the data
2. Get to grips with the structure of the data
3. Select the `patient_id`, `systolic_pressure` and `body_temperature` columns
4. Select all numerical columns
5. Unselect all logical columns

::: {.callout-answer collapse="true"}
#### 1. Read in the data

First we load the data, and have a glimpse of it.

::: {.panel-tabset group="language"}
## R

```{r}
#| message: false
infections <- read_csv("data/infections.csv")
```

```{r}
head(infections)
```


## Python

```{python}
infections = pd.read_csv("data/infections.csv")

infections.head()
```

:::

#### 2. Get to grips with the structure of the data

Before delving into any analysis, it's always good to have a good look at your data, so you know what you're dealing with. We can look at the overall structure (focussing on the column types & checking if they make sense), at number of columns/observations, column names, summary statistics etc.

::: {.panel-tabset group="language"}
## R

```{r}
str(infections) # overall structure
```

```{r}
nrow(infections) # row number
ncol(infections) # column number
```

```{r}
colnames(infections) # column names
```

```{r}
summary(infections) # summary statistics
```

## Python

```{python}
infections.info() # overall structure
```

```{python}
infections.shape[0] # row number
infections.shape[1] # column number
```

```{python}
infections.columns # column names
```

```{python}
infections.describe() # summary statistics
```

:::

Now that we have a much better view of what our data looks like, let's play around with selecting and manipulating columns.

#### 3. Select the `patient_id`, `systolic_pressure` and `body_temperature` columns

::: {.panel-tabset group="language"}
## R

```{r}
select(infections, patient_id, systolic_pressure, body_temperature)
```


## Python

We use the `[[ ]]` notations, because we are subsetting the DataFrame (`infections[ ]`) and we are subsetting it by using a list of column names `["patient_id", "systolic_pressure", "body_temperature"]`:

```{python}
infections[["patient_id", "systolic_pressure", "body_temperature"]]
```

:::

#### 4. Select all numerical columns

::: {.panel-tabset group="language"}
## R

```{r}
select(infections, where(is.numeric))
```


## Python

```{python}
infections.select_dtypes(include = ["number"])
```

:::

#### 5. Unselect all logical columns

::: {.panel-tabset group="language"}
## R

We can do something similar as with the numerical column, just specifying the `logical` type and then negating it:

```{r}
select(infections, -where(is.logical))
```

## Python

We can do something similar as with the numerical column, just specifying the `bool` type and now excluding it:

```{python}
infections.select_dtypes(exclude = ["bool"])
```

:::
:::
:::

### Creating columns: `body_temperature_f` {#sec-exr_bodytempf}

::: {.callout-exercise #ex-bodytempf}
#### Creating columns

{{< level 2 >}}

For this exercise we'll again use the data from `data/infections.csv`. We'll assume you've still have it read in. Please try the following:

Create a `body_temperature_f` that contains the body temperature measurements in Fahrenheit.


::: {.callout-hint collapse="true"}
To convert Celsius to Fahrenheit, do the following:

$$
F = \left( C \times \frac{9}{5} \right) + 32
$$

:::

::: {.callout-answer collapse="true"}

We need to update the existing table, so we view the result.

::: {.panel-tabset group="language"}
## R

```{r}
infections <- mutate(infections, body_temperature_f = body_temperature * (9/5) + 32)
```

Let's check if the result is what we expected.

```{r}
select(infections, body_temperature, body_temperature_f)
```

## Python

```{python}
infections["body_temperature_f"] = infections["body_temperature"] * (9/5) + 32
```

Let's check if the result is what we expected.

```{python}
infections[["body_temperature", "body_temperature_f"]]
```

:::

:::
:::

### Creating and plotting columns {#sec-exr_createplotcols}

::: {.callout-exercise #ex-createplotcols}
#### Creating and plotting columns

{{< level 2 >}}

We'll again use the `infections` data set, but this time we want you to fix the code below to recreate the image. To do so, please change all the `<FIXME>` entries to the correct code.

::: {.panel-tabset group="language"}
## R

```{r}
#| eval: false
# create the column for the y-axis values
infections <- mutate(infections, systolic_pressure_kpa = <FIXME> / 7.5006)

# plot the data
ggplot(infections, aes(x = <FIXME>, y = systolic_pressure_kpa)) +
  geom_<FIXME>(aes(fill = <FIXME>))
```
```{r}
#| echo: false
#| warning: false
# create the column for the y-axis values
infections <- mutate(infections, systolic_pressure_kpa = systolic_pressure / 7.5006)

# plot the data
ggplot(infections, aes(x = age_group, y = systolic_pressure_kpa)) +
  geom_boxplot(aes(fill = icu_admission))
```

## Python

```{python}
#| eval: false
# create the column for the y-axis values
infections["systolic_pressure_kpa"] = infections["<FIXME>"] / 7.5006

# plot the data
p = (ggplot(infections, aes(x = "<FIXME>", y = "systolic_pressure_kpa")) +
  geom_<FIXME>(aes(fill = "<FIXME>")))
  
p.show()
```

```{python}
#| echo: false
#| results: hide
# create the column for the y-axis values
infections["systolic_pressure_kpa"] = infections["systolic_pressure"] / 7.5006

# plot the data
p = (ggplot(infections, aes(x = "age_group", y = "systolic_pressure_kpa")) +
  geom_boxplot(aes(fill = "icu_admission")))
  
p.show()
```

:::

::: {.callout-note collapse="true"}
## mmHg to kPa
$$
1\ \text{kPa} \approx 7.5006\ \text{mmHg}
$$

:::

::: {.callout-answer collapse="true"}

::: {.panel-tabset group="language"}
## R

```{r}
#| eval: false
# create the column for the y-axis values
infections <- mutate(infections,
                     systolic_pressure_kpa = systolic_pressure / 7.5006)

# plot the data
ggplot(infections, aes(x = age_group, y = systolic_pressure_kpa)) +
  geom_boxplot(aes(fill = icu_admission))
```

## Python

```{python}
#| eval: false
# create the column for the y-axis values
infections["systolic_pressure_kpa"] = infections["systolic_pressure"] / 7.5006

# plot the data
p = (ggplot(infections, aes(x = "age_group", y = "systolic_pressure_kpa")) +
  geom_boxplot(aes(fill = "icu_admission")))
  
p.show()
```

:::

:::
:::


## Summary

::: {.callout-tip}
#### Key points

- We have several functions available that allow us to select, move, rename and create new columns
:::
