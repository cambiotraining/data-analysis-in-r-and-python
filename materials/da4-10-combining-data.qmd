---
title: Combining data
---

::: {.callout-tip}
#### Learning objectives

- Learn how to join two tables together.
- Be able to distinguish between different types of joins.
- Use filtering joins to identify (mis)matches between tables.
:::


## Context
Data is often split over multiple tables. We saw this in the previous section. Sometimes we need to combine information from multiple sources.

## Section setup {#setup_grouped_operations}

::: {.panel-tabset group="language"}
## R

We'll continue this section with the script named `r paste0(intToUtf8(96), sub("\\..*$", ".R", knitr::current_input()), intToUtf8(96))`. If needed, add the following code to the top of your script and run it.

```{r}
#| message: false
# A collection of R packages designed for data science
library(tidyverse)

surveys <- read_csv("data/surveys.csv")
plot_types <- read_csv("data/plots.csv")
species <- read_csv("data/species.csv")
```

## Python

We'll continue this section with the script named `r paste0(intToUtf8(96), sub("\\..*$", ".py", knitr::current_input()), intToUtf8(96))`. If needed, add the following code to the top of your script and run it.

```{python}
# A Python data analysis and manipulation tool
import pandas as pd

# Python equivalent of `ggplot2`
from plotnine import *

surveys = pd.read_csv("data/surveys.csv")
plot_types = pd.read_csv("data/plots.csv")
species = pd.read_csv("data/species.csv")
```

:::

## Joining tables
We've already seen that some of our data sets have an identifier, for example the `record_id` in the `surveys` data set.

When it comes to joining data, these identifiers become extra important. After all, we need to be able to tell the computer *how* to join the data. We do this through a common key or variable between two data sets. We'll illustrate how this works below.

### Setting up your joins {#setup_joins}
There are different ways you can join tables, depending on which data you'd like to retain. The way these joins are named often depend on the *direction* in which you are joining. Let's look at this in more detail, using examples.

::: {.panel-tabset group="language"}
## R

```{r}
plot_types <- read_csv("data/plots.csv")
```

Let's look at the data. We can see that there are five distinct plot types encoded in these data, using `plot_id` as a key.

```{r}
plot_types
```

Now let's look at our `surveys` data set. We know we have a `plot_id` column there, too. Let's check how many times the different `plot_id` values occur in our data. For this, we can use the `count()` function:

```{r}
surveys |> count(plot_id)
```

This shows that there are 24 `plot_id` values (there are 24 rows in the output). So, the `plot_types` data set won't contain information on *all* of these, since it only contains 5 distinct plots.

## Python

```{python}
plot_types = pd.read_csv("data/plots.csv")
```

Let’s look at the data. We can see that there are five distinct plot types encoded in these data, using `plot_id` as a key.

```{python}
plot_types
```

Now let’s look at our `surveys` data set. We know we have a `plot_id` column there, too. Let’s check how many times the different `plot_id` values occur in our data. 

```{python}
surveys.groupby('plot_id').size().reset_index(name='n')
```

This shows that there are 24 `plot_id` values (there are 24 rows in the output). So, the `plot_types` data set won’t contain information on all of these, since it only contains 5 distinct plots.
:::

### Left joins

We'll be adding the data from `plot_types` to the existing `surveys` data. This uses the following principle:

![Left join: table b to a](images/join_left.png){#fig-join_left}

This means that any `plot_id` that appears in `surveys`, but isn't present in `plot_types` will be empty or missing for its `plot_type` value.

::: {.panel-tabset group="language"}
## R

```{r}
left_join(surveys, plot_types, by = "plot_id")
```

Let's assign that output to an object called `surveys_left`.

```{r}
surveys_left <- left_join(surveys, plot_types, by = "plot_id")
```

## Python

```{python}
surveys_left = pd.merge(surveys, plot_types, how = "left", on = "plot_id")
```

```{python}
surveys_left
```

:::

Having this information now allows us to plot the data by `plot_type` in a much more meaningful way than if we would have used `plot_id`. For example, let's look at the `hindfoot_length` for each `plot_type`.

::: {.panel-tabset group="language"}
## R

```{r}
#| label: fig-plot_hind
#| fig-cap: "Boxplot of hindfoot length for each plot type"
ggplot(surveys_left, aes(x = plot_type, y = hindfoot_length)) +
  geom_boxplot()
```


## Python

```{python}
#| results: hide
#| label: fig-plot_hind_py
#| fig-cap: "Boxplot of hindfoot length for each plot type"
p = (ggplot(surveys_left, aes(x = "plot_type", y = "hindfoot_length")) +
  geom_boxplot())
  
p.show()
```

:::

### Right joins

![Right join: table a to b](images/join_right.png){#fig-join_right}

::: {.panel-tabset group="language"}
## R

```{r}
right_join(surveys, plot_types, by = "plot_id")
```

## Python

```{python}
surveys_right = pd.merge(surveys, plot_types, how = "right", on = "plot_id")
```

Let's see how many rows we've retained.

```{python}
len(surveys_right)
```

:::

We can see that we have far fewer rows left (`r right_join(surveys, plot_types, by = "plot_id") |> nrow()`) than in the full data set (`r surveys |> nrow()`). This is because all the rows where there isn't a match for `plot_id` in the `surveys` data set are dropped.

### Inner joins

![Inner join: retain values present in both tables](images/join_inner.png){#fig-join_inner}

::: {.panel-tabset group="language"}
## R

```{r}
inner_join(surveys, plot_types, by = "plot_id")
```

## Python

```{python}
surveys_inner = pd.merge(surveys, plot_types, how = "inner", on = "plot_id")
```

Let's see how many rows we've retained. We can either use `.shape[0]` or `len()`.

```{python}
len(surveys_inner)
```

:::

This actually gives the same result as with the right join (`r right_join(surveys, plot_types, by = "plot_id") |> nrow()`  rows), which is because there aren't any rows in `plot_type` that *don't* have a match in `surveys`.

### Full joins

![Full join: retain all values](images/join_full.png){#fig-join_full}

::: {.panel-tabset group="language"}
## R

```{r}
full_join(surveys, plot_types, by = "plot_id")
```

## Python

The "full" join in pandas' `merge()` function is referred to as `"outer"`.

```{python}
surveys_full = pd.merge(surveys, plot_types, how = "outer", on = "plot_id")
```

Let's see how many rows we've retained.

```{python}
len(surveys_full)
```

:::

This again gives us our entire `surveys` data set, including the additional `plot_type` information where available. The reason why this is not different to the left join is because there are no rows in `plot_types` that do not have a match in `surveys`.

### Filtering joins

There is one last set of joins we haven't discussed yet: filtering joins. These can be really helpful if you're comparing two tables and want to specifically extract the rows that are either present (**semi-join**) or absent (**anti-join**) in the other table.

::: {.panel-tabset group="language"}
## R

Semi-join:

```{r}
semi_join(surveys, plot_types, by = "plot_id")
```

Anti-join:

```{r}
anti_join(surveys, plot_types, by = "plot_id")
```

## Python

Semi-join:

```{python}
surveys[surveys["plot_id"].isin(plot_types["plot_id"])]
```

Anti-join:

```{python}
surveys[~surveys["plot_id"].isin(plot_types["plot_id"])]
```

:::

## Exercises

### Simple joins: `surveys` {#sec-exr_simple_joins}

::::: {.callout-exercise #ex-simple_joins}
#### Simple joins

{{< level 1 >}}

For this exercise we'll be using the data from `data/surveys.csv` and `data/species.csv`.

We've of course seen the `surveys` data set more times than we can remember, but it's still got more to give. In fact, we are going to add to it. We currently have a rather uninformative `species_id` column.

For this exercise, we're going to link that with the data from `species`, which has more useful descriptions and additional data.

As an aside, this is not a bad data strategy at all - splitting your data across multiple tables. That way you don't end up with gigantic tables that contain lots of data you might only need for very specific purposes. Or data that you might not want to share freely (e.g. patient or customer data).

Without further ado, please do the following:

1. Load the data
2. Join the two tables (consider *how*!) & inspect the output

:::: {.callout-answer collapse="true"}
#### 1. Loading the data

First, we read in the data and have a look at the structure of `species`.

::: {.panel-tabset group="language"}
## R

```{r}
#| message: false
species <- read_csv("data/species.csv")
```

## Python

```{python}
species = pd.read_csv("data/species.csv")
```

:::

Let's look at what we've got.

::: {.panel-tabset group="language"}
## R

```{r}
head(species)
```


## Python

```{python}
species.head()
```

:::

So, the column we have in common between `species` and `surveys` is the `species_id` column. That will be our **key** column that we'll use to join the data.

#### 2. Joining the tables and inspecting the output

We'll be joining the `species` table to the `surveys` table, so we'll join **left**: `surveys <<< species`.

::: {.panel-tabset group="language"}
## R

```{r}
surveys_species <- left_join(surveys, species, by = "species_id")

head(surveys_species)
```


## Python

```{python}
surveys_species = surveys.merge(species, on = "species_id", how = "left")

surveys_species.head()
```

:::

We can see that the data from `species` has been joined with `surveys`, since we now have `genus`, `species` and `taxa` columns in our data set.

::::
:::::

## Summary

::: {.callout-tip}
#### Key points

- We can use left, right, inner and outer/full joins to merge two tables together.
- There needs to be at least one matching column between the two tables that can be used as a key to link them.
- We can also use filter joins to identify rows in a table that are present/absent in the other
:::
