{
  "hash": "213cb7a97e28b9767f8b4ae657e4b9ee",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Plotting data\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.callout-tip}\n#### Learning objectives\n\n- Learn to create plots\n- Be able to build up plots in multiple layers\n- Make changes to plot colours and other aesthetics\n- Be able to create sub-panels based on data\n- Export/save plots to file\n:::\n\n## Context\nWe now have a good grasp of how data is commonly structured, with variables in columns and observations in rows. This is the perfect format for visualising data.\n\n## Section setup {#setup_plotting}\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe'll continue this section with the script named `da2-04-plotting.R`. If needed, add the following code to the top of your script and run it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A collection of R packages designed for data science\nlibrary(tidyverse)\n\nsurveys <- read_csv(\"data/surveys.csv\")\n```\n:::\n\n\n## Python\n\nWe'll continue this section with the script named `da2-04-plotting.py`. If needed, add the following code to the top of your script and run it.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# A Python data analysis and manipulation tool\nimport pandas as pd\n\n# Python equivalent of `ggplot2`\nfrom plotnine import *\n\nsurveys = pd.read_csv(\"data/surveys.csv\")\n```\n:::\n\n\n:::\n:::\n\n## Introducing plotting\n\nTo create a plot we'll need three things:\n\n| | | |\n|------|-------------|--------------------------------|\n| <i class=\"fa fa-table-list fa-1x\"></i> | 1. Data | your data |\n| <i class=\"fa fa-chart-line fa-1x\"></i> | 2. Mapping aesthetics | variables used to create the visual (e.g. x/y data, colours) |\n| <i class=\"fa fa-chart-column fa-1x\"></i> | 3. Specify the type of plot | e.g. scatter plot, boxplot, line graph |\n\nThis breakdown of plotting is often associated with R's `ggplot2` package, but the underlying principles of the `gg` (**grammar of graphics**) is a much more universal approach to creating graphs.\n\nThe idea is that you consistently build up plots, layer-by-layer. I like the concept, because it creates consistency in our approach - regardless of the language. There is a Python implementation of `ggplot2`, called `plotnine`.\n\nWe'll be using these libraries/modules here, but will also show you some examples of other commonly-used plotting packages. You'll probably develop your own preference - this is absolutely fine!\n\n\n### Start plotting\n\nIf needed, add and run the code from [Section setup](#setup_plotting).\n\nHere we are using the `surveys` data set. Let's assume that we're interested in the relationship between two variables: `weight` and `hindfoot_length`. We can plot `weight` on the x-axis and `hindfoot_length` on the y-axis.\n\nSince they are both continuous data, a scatter plot would be a good way to represent these data.\n\nSo, we need three things: (1) data; (2) mapping of aesthetics and (3) specify the type of plot.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe use the `ggplot()` function to do this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = surveys,\n       mapping = aes(x = weight, y = hindfoot_length)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## Python\n\nWe use the `ggplot()` function to do this. Note that the whole code chunk below is wrapped inside another set of parentheses `( )`. This allows us to break up the code a bit for clarity. Also, the variable names that we're giving to `ggplot()` are inside quotes `\" \"` - this is different from R, where this is not necessary.\n\nAdditionally, if you're running this directly from a Python script, it might not always output the plot inline. To avoid issues with this, we assign the plot to an object `p` and specifically ask Python to display it using `p.show()`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(data = surveys,\n        mapping = aes(x = \"weight\", y = \"hindfoot_length\")) + \n  geom_point())\n\np.show()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-6-1.png){width=614}\n:::\n:::\n\n\n:::\n\nLet's unpack that a bit. We specify which data to use with the `data =` argument (our `surveys` data set in this case).\n\nNext, we define what goes onto the `x` and `y` axes, using the `mapping =` argument. This needs a so-called *helper function* `aes()`, which stands for *aesthetics*. Within this helper function we define what goes onto the x-axis (`x =`) and y-axis (`y =`).\n\nFinally, we need to tell it *what kind of plot* we want. Here, we want to use a scatter plot. The type of plot is determined by the `geom_`. This literally gets added to the `ggplot()` function: note the `+` symbol at the end of the line of code.\n\nMost `geom_` functions are logically named. For example, a line graph will be `geom_line()`, a boxplot `geom_boxplot()` etc. The odd one out is the scatter plot, which is `geom_point()`, because we're plotting individual data points.\n\nWe don't have to add any information within the `geom_point()` function, because it's taking all it needs from the `ggplot()` function above. More on this later.\n\n### Building up plots\n\nThe good thing about `ggplot()` is that it builds up the plot layer-by-layer. We don't even have to provide it with a geometry to start with and it'll still create the outline of a plot.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = surveys,\n       mapping = aes(x = weight, y = hindfoot_length))\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-7-3.png){width=672}\n:::\n:::\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(data = surveys,\n        mapping = aes(x = \"weight\", y = \"hindfoot_length\")))\n\np.show()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-8-1.png){width=614}\n:::\n:::\n\n:::\n\nHowever, that obviously is not very useful. The nice thing is that we can add multiple layers to a single plot. Let's illustrate this with a different example. We have a column `sex` in the data. This contains three possible values:`F` (female),  `M` (male) and `NA` (not recorded).\n\nLet's look at the hindfoot length distribution across these groups.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = surveys,\n       mapping = aes(x = sex, y = hindfoot_length)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-9-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(data = surveys,\n        mapping = aes(x = \"sex\", y = \"hindfoot_length\")) +\n        geom_point())\n\np.show()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-10-1.png){width=614}\n:::\n:::\n\n:::\n\nA lot of the points are overlapping, which makes it a bit hard to see how the data are distributed. We can do something about that (more on that in the next session), but we can also add some summary statistics in the form of a boxplot. We can simply add a layer to the plot that displays the boxes.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = surveys,\n       mapping = aes(x = sex, y = hindfoot_length)) +\n  geom_point() +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-11-3.png){width=672}\n:::\n:::\n\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(data = surveys,\n        mapping = aes(x = \"sex\", y = \"hindfoot_length\")) +\n        geom_point() +\n        geom_boxplot())\n\np.show()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-12-1.png){width=614}\n:::\n:::\n\n:::\n\nThe layers are added in the order we provide them, so here the boxes are on top of the individual data points. You might want to rearrange that, so that the boxes are *behind* the data.\n\n## Changing plots\n\nOften we want to control other parts of the plot as well. There is a whole range of things we can change about the appearance of a plot - in fact, *anything* in a plot can be changed! Don't try to remember every tiny detail. You might want to change the orientation of the text labels on the x-axis, but a quick search is probably easier than keeping that information in your head!\n\n### Colour\n\nChanging colour is pretty straightforward. We use the `colour =` argument. There are a whole range of default colours available, but we'll go with blue here.\n\nLet's illustrate that using our original `weight` vs `hindfoot_length` scatter plot.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = surveys,\n       mapping = aes(x = weight, y = hindfoot_length)) +\n  geom_point(colour = \"blue\")\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-13-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(data = surveys,\n        mapping = aes(x = \"weight\", y = \"hindfoot_length\")) +\n        geom_point(colour = \"blue\"))\n\np.show()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-14-1.png){width=614}\n:::\n:::\n\n:::\n\n### Fill\n\nThe `fill =` argument is used to *fill* surface areas. It doesn't work on individual points, but instead on geometries that have an area, such as a boxplot, bar chart or violin plot.\n\nWe can't create a boxplot with two continuous variables, so we'll plot `hindfoot_length` for the different `sex` groups again. We fill the boxes using magenta.\n\n**What happens if you use `colour = \"magenta\"` instead?**\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = surveys,\n       mapping = aes(x = sex, y = hindfoot_length)) +\n  geom_boxplot(fill = \"magenta\")\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-15-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(data = surveys,\n        mapping = aes(x = \"sex\", y = \"hindfoot_length\")) +\n        geom_boxplot(fill = \"magenta\"))\n\np.show()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-16-1.png){width=614}\n:::\n:::\n\n:::\n\n### Aesthetics based on data\n\nManually assigning colours can be very helpful, but quite often we want to colour data based on *another variable*. For example, we might be interested in the potential relationship between weight and hindfoot length, but are wondering if this looks different across the sex groups.\n\nIn that case, we'd want to colour all the data points belonging to the male group different to those of the female group. The same goes for the missing values.\n\nThe way we can do this is by adding the `sex` variable *inside* the aesthetics.\n\n::: {.callout-note}\n## Within `aes()` or not?\n\nAn easy way of remembering where your `colour =` or `fill =` argument goes is to ask: is the colour based on the data or not? If the answer is yes, it goes *inside* the aesthetics. If not, then outside.\n\n:::\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = surveys,\n       mapping = aes(x = weight, y = hindfoot_length, colour = sex)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-17-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(data = surveys,\n        mapping = aes(x = \"weight\", y = \"hindfoot_length\", colour = \"sex\")) +\n        geom_point())\n\np.show()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-18-1.png){width=614}\n:::\n:::\n\n:::\n\n### Dealing with overlap\n\nIn the example of hindfoot length for the different sex groups we noticed that there is quite a bit of overlap in the data. One of the ways of dealing with this is by adding a little bit of *jitter*. What that does is add a tiny bit of random noise to the data, to avoid overlap.\n\nWe can do this with the `geom_jitter()` geometry. The amount of jitter that is added can be regulated with the `width =` argument, as a fraction of the available width. Compare the differences in the following plots.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = surveys,\n       mapping = aes(x = sex, y = hindfoot_length)) +\n  geom_jitter()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-19-3.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = surveys,\n       mapping = aes(x = sex, y = hindfoot_length)) +\n  geom_jitter(width = 0.1)\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(data = surveys,\n        mapping = aes(x = \"sex\", y = \"hindfoot_length\")) +\n        geom_jitter())\n\np.show()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-21-1.png){width=614}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(data = surveys,\n        mapping = aes(x = \"sex\", y = \"hindfoot_length\")) +\n        geom_jitter(width = 0.1))\n\np.show()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-22-3.png){width=614}\n:::\n:::\n\n:::\n\n### Transparency\n\nEven with jittering the data, we still have quite some overlap. There probably is a limit to what we can do about it, but adding some transparency can also help. Here, where there is more overlap, areas will appear darker whereas less overlap will appear lighter.\n\nWe control this with the `alpha =` argument. Again, this takes a value between 0 (full transparency) and 1 (no transparency).\n\nCompare the following plot with the previous ones.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = surveys,\n       mapping = aes(x = sex, y = hindfoot_length)) +\n  geom_jitter(width = 0.1, alpha = 0.4)\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-23-5.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(data = surveys,\n        mapping = aes(x = \"sex\", y = \"hindfoot_length\")) +\n        geom_jitter(width = 0.1, alpha = 0.4))\n\np.show()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-24-1.png){width=614}\n:::\n:::\n\n:::\n\n### Point size and line width\n\nThe `size =` argument is used to control the size of points, whereas the `linewidth =` argument is used to specify line thickness. Look at the following examples.\n\nIn the next two panels we're using `geom_point()` with different sizes.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-25-3.png){width=672}\n:::\n:::\n\n\nThe following two panels use a different geometry: `geom_smooth()`. This creates a smoothed line across the data. The width of the line can be changed with the `linewidth =` argument.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n## Facets\n\nPlots can split into multiple panels using *faceting*. This is a very useful tool to quickly see data distributions across different groups. We can split them into two types:\n\n1. `facet_wrap()` arranges a one-dimensional sequence of panels (based on a single splitting variable) to fit on one page\n2. `facet_grid()` allows you to form a matrix of rows and columns of panels (based on two different variables)\n\nThis is best illustrated with an example. Let's say we want to split the weight vs hindfoot length scatter plot by the different sex groups, where the data belonging to each group has its own sub-panel. We can do this as follows.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = surveys,\n       mapping = aes(x = weight, y = hindfoot_length)) +\n  geom_point() +\n  facet_wrap(facets = vars(sex))\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\nNote the added code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfacet_wrap(facets = vars(sex))\n```\n:::\n\n\nWe used `facet_wrap()`, because we're only splitting the data by a single variable: `sex`. We also need to tell the function which variable to split by, which we do in the `facets =` argument. Annoyingly - and for reasons unbeknownst to me - this requires the use of a *helper function*, `vars()`.\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(surveys, aes(x = \"weight\", y = \"hindfoot_length\")) +\n        geom_point() +\n        facet_wrap(\"~ sex\"))\n\np.show()\n```\n\n::: {.cell-output-display}\n![](da2-04-plotting_files/figure-html/unnamed-chunk-29-1.png){width=614}\n:::\n:::\n\n\nNote the added code:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfacet_wrap(\"~ sex\")\n```\n:::\n\n\nWe used `facet_wrap()`, because we're only splitting the data by a single variable: `sex`. We also need to tell the function which variable to split by, which we do by using the `~` symbol. I completely agree that this is a weird notation. Just read it as *split by...*\n\n:::\n\nIn the end, our data is split into three sub-panels - one for each group. This makes it easy to see trends across the groups. Or, in this case, that there doesn't seem to be much difference in the distribution across the female and male observations.\n\n## Saving plots\n\nSometimes you might want to save a plot you created. This is pretty straightforward. Here, we are assuming that you have an `images` subfolder in your working directory.\n\nWe save a plot in two steps:\n\n1. Assign the plot to an object\n2. Then use `ggsave()` to save this object\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_r <- ggplot(data = surveys,\n       mapping = aes(x = weight, y = hindfoot_length)) +\n  geom_point() +\n  facet_wrap(facets = vars(sex))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggsave(filename = \"images/height_vs_hindfootlength.png\",\n       plot = plot_r,\n       width = 7,\n       height = 5,\n       units = \"in\")\n```\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nplot_python = (ggplot(surveys, aes(x = \"weight\", y = \"hindfoot_length\")) +\n        geom_point() +\n        facet_wrap(\"~ sex\"))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(ggsave(plot_python,\n        filename = \"images/height_vs_hindfootlength.png\",\n        units = \"in\",\n        width = 7,\n        height = 5))\n```\n:::\n\n\n:::\n\nHere, I've added a few extra arguments to demonstrate what you can change. The only two things that are required are (1) the plot you want to save and (2) the name of the plot, including the filename extension.\n\nThe other arguments, such as `units =`, `width =` and `height =` are used to define the units size (inches in this case) and corresponding width/height values.\n\n## Summary\n\n::: {.callout-tip}\n#### Key points\n\n- We can build up plots layer-by-layer, adding multiple geometries in a single plot\n- Plot aesthetics can be changed based on data or manually defined\n- Colour, fill, transparency and jittering can all be useful ways to improve clarity\n- Plots can be subdivided into panels, called *facets*, which are based on a variable within the data. This allows easy visual comparison across groups.\n- We use functions like `ggsave()` to export plots to file\n:::\n",
    "supporting": [
      "da2-04-plotting_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}