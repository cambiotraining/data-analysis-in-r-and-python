{
  "hash": "285bce9d662a136a442f7a93e2e70511",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Live demo exercises\"\n---\n\n## Section setup\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# A Python data analysis and manipulation tool\nimport pandas as pd\n\n# Python equivalent of `ggplot2`\nfrom plotnine import *\n\n# If using seaborn for plotting\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n```\n:::\n\n\n:::\n\n## DA1: getting started\n\nThis is a hands-on demo.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nLive demo RStudio:\n\n* open RStudio\n* highlight panels\n* change default settings (`.Rdata` and not save workspace)\n* set up new RProject  `data-analysis`\n* create the subfolders (`data`, `images`, `scripts`)\n* create a script\n* download and copy the data files into `data`\n\n\n## Python\n\nLive demo JupyterLab:\n\n* open JupyterLab\n* highlight Launcher\n* show how to check working directory, change if needed (`data-analysis`)\n* create the subfolders (`data`, `images`, `scripts`) \n* create a Notebook\n* download and copy the data files into `data`\n\n\n:::\n\n## DA1: data types\n\nImportant to realise that there often is some order to how data types are interpreted. For example, look at the following:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample <- c(22, 87, NA, 32)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(example)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample <- c(22, 87, NA, \"unsure\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(example)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n## Python\n\n:::\n\n## DA1: indexing\n\nA bit of a technical detail, but an important one, particularly if you're using both R and Python. The main focus of the example is **not** on the subsetting, it's on the fact that R has 1-based indexing and Python has 0-based indexing.\n\nFurthermore, that R's indexing is inclusive, and Python's exclusive (comparing `1:3` in R vs Python). That said, it's to create awareness of the fact that indexing has to start somewhere and that it can be different between programming languages.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwinnings <- c(\"first\", \"second\", \"third\", \"fourth\")\n```\n:::\n\n\nThe positional index is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_along(winnings)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4\n```\n\n\n:::\n:::\n\n\nSo, if we wanted to select the first and third values, we'd do:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwinnings[c(1, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"first\" \"third\"\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nwinnings = [\"first\", \"second\", \"third\", \"fourth\"]\n```\n:::\n\n\nThe positional index is as follows:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlist(range(len(winnings)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[0, 1, 2, 3]\n```\n\n\n:::\n:::\n\n\nSo, if we wanted to select the first and third values, we'd do:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nwinnings[0]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'first'\n```\n\n\n:::\n\n```{.python .cell-code}\nwinnings[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'third'\n```\n\n\n:::\n:::\n\n\n:::\n\n\n## DA2: data exploration\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nRead in the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections <- read_csv(\"data/infections.csv\")\n```\n:::\n\n\nAnd have a look:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(infections)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 11\n  patient_id hospital   quarter infection_type vaccination_status age_group\n  <chr>      <chr>      <chr>   <chr>          <chr>              <chr>    \n1 ID_0001    hospital_3 Q2      none           <NA>               65+      \n2 ID_0002    hospital_3 Q2      viral          <NA>               18 - 64  \n3 ID_0003    hospital_2 Q2      none           unknown            65+      \n4 ID_0004    hospital_2 Q3      fungal         unvaccinated       < 18     \n5 ID_0005    hospital_3 Q2      fungal         vaccinated         65+      \n6 ID_0006    hospital_5 Q3      none           vaccinated         65+      \n# ℹ 5 more variables: icu_admission <lgl>, symptoms_count <dbl>,\n#   systolic_pressure <dbl>, body_temperature <dbl>, crp_level <dbl>\n```\n\n\n:::\n:::\n\n\n\n## Python\n\nRead in the data:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ninfections = pd.read_csv(\"data/infections.csv\")\n```\n:::\n\n\nAnd have a look:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ninfections.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  patient_id    hospital  ... body_temperature crp_level\n0    ID_0001  hospital_3  ...             37.8     12.05\n1    ID_0002  hospital_3  ...             39.1      8.11\n2    ID_0003  hospital_2  ...             38.5      5.24\n3    ID_0004  hospital_2  ...             39.4     41.73\n4    ID_0005  hospital_3  ...             36.9     10.51\n\n[5 rows x 11 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\n### Data structure\n\nNumber of rows & columns:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(infections)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1400\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nncol(infections)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ninfections.shape[0]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1400\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ninfections.shape[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n11\n```\n\n\n:::\n:::\n\n\n\n:::\n\nIt's good to look at the column attributes: what type of columns are we dealing with and is it what we expect?\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(infections)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  patient_id          hospital           quarter          infection_type    \n Length:1400        Length:1400        Length:1400        Length:1400       \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n                                                                            \n vaccination_status  age_group         icu_admission   symptoms_count  \n Length:1400        Length:1400        Mode :logical   Min.   : 0.000  \n Class :character   Class :character   FALSE:814       1st Qu.: 6.000  \n Mode  :character   Mode  :character   TRUE :513       Median : 9.000  \n                                       NA's :73        Mean   : 8.549  \n                                                       3rd Qu.:11.000  \n                                                       Max.   :21.000  \n                                                       NA's   :67      \n systolic_pressure body_temperature   crp_level     \n Min.   : 87.0     Min.   :36.30    Min.   : 1.000  \n 1st Qu.:118.0     1st Qu.:38.20    1st Qu.: 9.117  \n Median :125.0     Median :38.80    Median :16.215  \n Mean   :125.1     Mean   :38.75    Mean   :19.465  \n 3rd Qu.:132.0     3rd Qu.:39.40    3rd Qu.:26.433  \n Max.   :163.0     Max.   :41.50    Max.   :58.860  \n NA's   :74        NA's   :67       NA's   :156     \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(infections)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nspc_tbl_ [1,400 × 11] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ patient_id        : chr [1:1400] \"ID_0001\" \"ID_0002\" \"ID_0003\" \"ID_0004\" ...\n $ hospital          : chr [1:1400] \"hospital_3\" \"hospital_3\" \"hospital_2\" \"hospital_2\" ...\n $ quarter           : chr [1:1400] \"Q2\" \"Q2\" \"Q2\" \"Q3\" ...\n $ infection_type    : chr [1:1400] \"none\" \"viral\" \"none\" \"fungal\" ...\n $ vaccination_status: chr [1:1400] NA NA \"unknown\" \"unvaccinated\" ...\n $ age_group         : chr [1:1400] \"65+\" \"18 - 64\" \"65+\" \"< 18\" ...\n $ icu_admission     : logi [1:1400] FALSE FALSE TRUE TRUE TRUE FALSE ...\n $ symptoms_count    : num [1:1400] 1 6 3 7 7 5 10 12 13 7 ...\n $ systolic_pressure : num [1:1400] 117 115 120 129 114 124 133 120 124 127 ...\n $ body_temperature  : num [1:1400] 37.8 39.1 38.5 39.4 36.9 36.8 39.4 39.3 39.6 39.1 ...\n $ crp_level         : num [1:1400] 12.05 8.11 5.24 41.73 10.51 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   patient_id = col_character(),\n  ..   hospital = col_character(),\n  ..   quarter = col_character(),\n  ..   infection_type = col_character(),\n  ..   vaccination_status = col_character(),\n  ..   age_group = col_character(),\n  ..   icu_admission = col_logical(),\n  ..   symptoms_count = col_double(),\n  ..   systolic_pressure = col_double(),\n  ..   body_temperature = col_double(),\n  ..   crp_level = col_double()\n  .. )\n - attr(*, \"problems\")=<externalptr> \n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ninfections.describe()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       symptoms_count  systolic_pressure  body_temperature    crp_level\ncount     1333.000000        1326.000000       1333.000000  1244.000000\nmean         8.549137         125.070136         38.751988    19.464751\nstd          3.825004          10.346761          0.883689    13.083907\nmin          0.000000          87.000000         36.300000     1.000000\n25%          6.000000         118.000000         38.200000     9.117500\n50%          9.000000         125.000000         38.800000    16.215000\n75%         11.000000         132.000000         39.400000    26.432500\nmax         21.000000         163.000000         41.500000    58.860000\n```\n\n\n:::\n:::\n\n\n:::\n\n### Quality control checks\n\nIt's good to do some basic sanity / quality control checks. For example, if there are different categories in a column, do all the categories we expect show up or are there missing ones / misspelled etc.?\n\nFor example, we can check the unique values in a column:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(infections$infection_type)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"none\"      \"viral\"     \"fungal\"    NA          \"bacterial\"\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ninfections[\"infection_type\"].unique()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray(['none', 'viral', 'fungal', nan, 'bacterial'], dtype=object)\n```\n\n\n:::\n:::\n\n\n:::\n\nWe can count the number of missing values in the column `infection_type`.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nYou read the code \"inside-out\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(is.na(infections$infection_type))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 74\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ninfections[\"infection_type\"].isna().sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n74\n```\n\n\n:::\n:::\n\n\n:::\n\n## DA2: subsetting tables\n\nLet's select `patient_id`:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections$patient_id\n```\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ninfections.patient_id\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0       ID_0001\n1       ID_0002\n2       ID_0003\n3       ID_0004\n4       ID_0005\n         ...   \n1395    ID_1396\n1396    ID_1397\n1397    ID_1398\n1398    ID_1399\n1399    ID_1400\nName: patient_id, Length: 1400, dtype: object\n```\n\n\n:::\n:::\n\n\n:::\n\nOr more than 1 column, by column name:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections[, c(\"patient_id\", \"systolic_pressure\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,400 × 2\n   patient_id systolic_pressure\n   <chr>                  <dbl>\n 1 ID_0001                  117\n 2 ID_0002                  115\n 3 ID_0003                  120\n 4 ID_0004                  129\n 5 ID_0005                  114\n 6 ID_0006                  124\n 7 ID_0007                  133\n 8 ID_0008                  120\n 9 ID_0009                  124\n10 ID_0010                  127\n# ℹ 1,390 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ninfections[[\"patient_id\", \"systolic_pressure\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     patient_id  systolic_pressure\n0       ID_0001              117.0\n1       ID_0002              115.0\n2       ID_0003              120.0\n3       ID_0004              129.0\n4       ID_0005              114.0\n...         ...                ...\n1395    ID_1396              118.0\n1396    ID_1397              117.0\n1397    ID_1398              137.0\n1398    ID_1399              135.0\n1399    ID_1400              129.0\n\n[1400 rows x 2 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\nCombine this with selecting only a subset of rows, let's say the first three rows.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections[1:3, c(\"patient_id\", \"systolic_pressure\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  patient_id systolic_pressure\n  <chr>                  <dbl>\n1 ID_0001                  117\n2 ID_0002                  115\n3 ID_0003                  120\n```\n\n\n:::\n:::\n\n\n## Python\n\nWe need to be aware of the zero-based indexing, also noting that the value after the `:` is *not* included:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ninfections[[\"patient_id\", \"systolic_pressure\"]].iloc[0:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  patient_id  systolic_pressure\n0    ID_0001              117.0\n1    ID_0002              115.0\n2    ID_0003              120.0\n```\n\n\n:::\n:::\n\n\n:::\n\n## DA2: simple plots\n\nLet's start with a simple scatterplot, where we plot `body_temperature` on the x-axis and `crp_level` on the y-axis.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(infections, aes(x = body_temperature, y = crp_level)) +\n  geom_point()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 215 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](trainers-live-demo_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(infections, aes(x = \"body_temperature\", y = \"crp_level\")) +\n  geom_point())\n  \np.show()\n```\n\n::: {.cell-output-display}\n![](trainers-live-demo_files/figure-html/unnamed-chunk-35-1.png){width=614}\n:::\n:::\n\n\n:::\n\nWe can explore this a bit further. For example, we can colour the points based on the `hospital` variable, to see if there are any patterns across the different hospitals:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(infections, aes(x = body_temperature, y = crp_level,\n                       colour = hospital)) +\n  geom_point()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 215 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](trainers-live-demo_files/figure-html/unnamed-chunk-36-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(infections, aes(x = \"body_temperature\", y = \"crp_level\",\n                            colour = \"hospital\")) +\n  geom_point())\n  \np.show()\n```\n\n::: {.cell-output-display}\n![](trainers-live-demo_files/figure-html/unnamed-chunk-37-1.png){width=614}\n:::\n:::\n\n\n:::\n\n## DA2: facetting data\n\nWhen we plotted `body_temperature` and `crp_level` against each other and coloured the data based on `hospital`, we ended up with a rather unclear plot. This is probably because there are no clear differences between the hospitals. However, we can separate these data a bit more clearly by using facets.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(infections, aes(x = body_temperature, y = crp_level,\n                       colour = hospital)) +\n  geom_point() +\n  facet_wrap(facets = vars(hospital))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 215 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](trainers-live-demo_files/figure-html/unnamed-chunk-38-3.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  ggplot(infections, aes(x = body_temperature, y = crp_level,\n                         colour = hospital)) +\n    geom_point() +\n    facet_grid(rows = vars(icu_admission), cols = vars(hospital))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 215 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](trainers-live-demo_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\np = (ggplot(infections, aes(x = \"body_temperature\", y = \"crp_level\",\n                            colour = \"hospital\")) +\n  geom_point() +\n  facet_wrap(\"~ hospital\"))\n  \np.show()\n```\n\n::: {.cell-output-display}\n![](trainers-live-demo_files/figure-html/unnamed-chunk-40-1.png){width=614}\n:::\n:::\n\n\n:::\n\n## DA3: selecting columns\n\nWe're practising two things:\n\n1. selecting columns\n2. creating columns (and highlight the use by plotting)\n\nLet's see which columns we have:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(infections)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"patient_id\"         \"hospital\"           \"quarter\"           \n [4] \"infection_type\"     \"vaccination_status\" \"age_group\"         \n [7] \"icu_admission\"      \"symptoms_count\"     \"systolic_pressure\" \n[10] \"body_temperature\"   \"crp_level\"         \n```\n\n\n:::\n:::\n\n\n\n## Python\n\n:::\n\nLet's say we only wanted to select some of these.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(infections, patient_id, body_temperature)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,400 × 2\n   patient_id body_temperature\n   <chr>                 <dbl>\n 1 ID_0001                37.8\n 2 ID_0002                39.1\n 3 ID_0003                38.5\n 4 ID_0004                39.4\n 5 ID_0005                36.9\n 6 ID_0006                36.8\n 7 ID_0007                39.4\n 8 ID_0008                39.3\n 9 ID_0009                39.6\n10 ID_0010                39.1\n# ℹ 1,390 more rows\n```\n\n\n:::\n:::\n\n\n\n## Python\n\n:::\n\nOr select by data type:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(infections, where(is.numeric))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,400 × 4\n   symptoms_count systolic_pressure body_temperature crp_level\n            <dbl>             <dbl>            <dbl>     <dbl>\n 1              1               117             37.8     12.0 \n 2              6               115             39.1      8.11\n 3              3               120             38.5      5.24\n 4              7               129             39.4     41.7 \n 5              7               114             36.9     10.5 \n 6              5               124             36.8      6.57\n 7             10               133             39.4     53.1 \n 8             12               120             39.3     NA   \n 9             13               124             39.6     50.3 \n10              7               127             39.1     13.0 \n# ℹ 1,390 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\n:::\n\nOr based on a certain phrase within the column heading:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(infections, contains(\"_id\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,400 × 1\n   patient_id\n   <chr>     \n 1 ID_0001   \n 2 ID_0002   \n 3 ID_0003   \n 4 ID_0004   \n 5 ID_0005   \n 6 ID_0006   \n 7 ID_0007   \n 8 ID_0008   \n 9 ID_0009   \n10 ID_0010   \n# ℹ 1,390 more rows\n```\n\n\n:::\n:::\n\n\n\n## Python\n\n:::\n\n## DA3: creating columns\n\nThere aren't too many variables in our data set that we can transform. However, the CRP levels are a good example. The CRP (C-reactive protein) is a continuous biomarker, often used clinically to indicate inflammation or infection severity. It can be skewed at times, so scaling it could be useful if you're making comparisons across groups.\n\n::: {.callout-note}\n## Scaling vs log-transforming\n\nThis falls well outside the scope of this course, but it's possible that the question comes up. We could also log-transform our data if there is an issue with skewing etc. Very simply & briefly put:\n\n* use `log()` when the distribution shape is the issue (e.g. skew, tails)\n* use `scale()` when the unit or range is the issue (often when comparing across different variables with different units)\n* using **both** can also be helpful, where you log-transform first, then scale the data to use in modelling.\n\n:::\n\nWe can scale the data where, for each value, we subtract the mean and divide by the standard deviation.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nIn R, we can use the `scale()` function to do this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(infections, crp_scaled = scale(crp_level))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,400 × 12\n   patient_id hospital   quarter infection_type vaccination_status age_group\n   <chr>      <chr>      <chr>   <chr>          <chr>              <chr>    \n 1 ID_0001    hospital_3 Q2      none           <NA>               65+      \n 2 ID_0002    hospital_3 Q2      viral          <NA>               18 - 64  \n 3 ID_0003    hospital_2 Q2      none           unknown            65+      \n 4 ID_0004    hospital_2 Q3      fungal         unvaccinated       < 18     \n 5 ID_0005    hospital_3 Q2      fungal         vaccinated         65+      \n 6 ID_0006    hospital_5 Q3      none           vaccinated         65+      \n 7 ID_0007    hospital_4 Q1      fungal         unvaccinated       18 - 64  \n 8 ID_0008    hospital_1 Q1      <NA>           unvaccinated       18 - 64  \n 9 ID_0009    hospital_2 Q1      viral          <NA>               65+      \n10 ID_0010    hospital_3 Q3      none           unvaccinated       <NA>     \n# ℹ 1,390 more rows\n# ℹ 6 more variables: icu_admission <lgl>, symptoms_count <dbl>,\n#   systolic_pressure <dbl>, body_temperature <dbl>, crp_level <dbl>,\n#   crp_scaled <dbl[,1]>\n```\n\n\n:::\n:::\n\n\nLet's store this in a temporary object, so we can visualise it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample <- mutate(infections, crp_scaled = scale(crp_level))\n```\n:::\n\n\nWe can then plot it, adding a reference line at `y = 0`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(example, aes(x = quarter, y = crp_scaled)) +\n  geom_jitter(width = 0.1) +\n  geom_hline(yintercept = 0, colour = \"blue\", linewidth = 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 156 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](trainers-live-demo_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n\n\n## Python\n\n:::\n\n## DA3: creating columns (conditional)\n\nSometimes we need to create new columns based on certain conditions. Let's say we wanted to flag if patients not vaccinated and have been admitted to ICU we consider them as high risk.\n\nWe want to encode this in a column `risk_factor`, where we label them as `\"high\"`. This would then allow us to add other values, such as `\"low\"` or `\"medium\"` at a later time.\n\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(infections,\n       risk_factor = ifelse(vaccination_status == \"unvaccinated\" & icu_admission == TRUE, \"high\", NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,400 × 12\n   patient_id hospital   quarter infection_type vaccination_status age_group\n   <chr>      <chr>      <chr>   <chr>          <chr>              <chr>    \n 1 ID_0001    hospital_3 Q2      none           <NA>               65+      \n 2 ID_0002    hospital_3 Q2      viral          <NA>               18 - 64  \n 3 ID_0003    hospital_2 Q2      none           unknown            65+      \n 4 ID_0004    hospital_2 Q3      fungal         unvaccinated       < 18     \n 5 ID_0005    hospital_3 Q2      fungal         vaccinated         65+      \n 6 ID_0006    hospital_5 Q3      none           vaccinated         65+      \n 7 ID_0007    hospital_4 Q1      fungal         unvaccinated       18 - 64  \n 8 ID_0008    hospital_1 Q1      <NA>           unvaccinated       18 - 64  \n 9 ID_0009    hospital_2 Q1      viral          <NA>               65+      \n10 ID_0010    hospital_3 Q3      none           unvaccinated       <NA>     \n# ℹ 1,390 more rows\n# ℹ 6 more variables: icu_admission <lgl>, symptoms_count <dbl>,\n#   systolic_pressure <dbl>, body_temperature <dbl>, crp_level <dbl>,\n#   risk_factor <chr>\n```\n\n\n:::\n:::\n\n\n\n## Python\n\n:::\n\n## DA4: reshaping data\n\nTo illustrate reshaping data, we're going to simplify our data set a little bit. First, we'll calculate the **average CRP levels** for each hospital, quarter, infection type, vaccination status and age group.\n\nWe'll use that summary table to highlight some use cases for reshaping data from a long to a wide format - and back.\n\n### Creating a summary table for CRP\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections_summary <- infections |> \n  drop_na() |> \n  group_by(hospital, quarter, infection_type, vaccination_status, age_group) |> \n  summarise(mean_crp = round(mean(crp_level, na.rm = TRUE), 2)) |> \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'hospital', 'quarter', 'infection_type',\n'vaccination_status'. You can override using the `.groups` argument.\n```\n\n\n:::\n:::\n\n\nLet's look at the output. We now have 6 columns, one for each of our grouping variables and at the end the `mean_crp` column containing the average CRP levels (rounded to two digits).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(infections_summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  hospital   quarter infection_type vaccination_status age_group mean_crp\n  <chr>      <chr>   <chr>          <chr>              <chr>        <dbl>\n1 hospital_1 Q1      bacterial      unknown            65+          23.7 \n2 hospital_1 Q1      bacterial      unknown            < 18         25.8 \n3 hospital_1 Q1      bacterial      unvaccinated       18 - 64       8.35\n4 hospital_1 Q1      bacterial      unvaccinated       65+          23.2 \n5 hospital_1 Q1      bacterial      unvaccinated       < 18         26.8 \n6 hospital_1 Q1      bacterial      vaccinated         18 - 64      22.4 \n```\n\n\n:::\n:::\n\n\n## Python\n\n:::\n\n### Wide table by quarter\n\nLet's say we'd be interested how the (average) CRP levels change over time across the different groupings. We'd be interested in having the `mean_crp` values for each `quarter` next to each other. That way we'd be able to plot quarterly average CRP levels against each other.\n\nWe can do this as follows:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections_wide <- infections_summary |> \n  pivot_wider(names_from = \"quarter\",\n              values_from = \"mean_crp\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(infections_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 7\n  hospital   infection_type vaccination_status age_group    Q1    Q2    Q3\n  <chr>      <chr>          <chr>              <chr>     <dbl> <dbl> <dbl>\n1 hospital_1 bacterial      unknown            65+       23.7   NA    26.8\n2 hospital_1 bacterial      unknown            < 18      25.8   54.5  NA  \n3 hospital_1 bacterial      unvaccinated       18 - 64    8.35  NA    NA  \n4 hospital_1 bacterial      unvaccinated       65+       23.2   28.6  NA  \n5 hospital_1 bacterial      unvaccinated       < 18      26.8   25.0  17.1\n6 hospital_1 bacterial      vaccinated         18 - 64   22.4   12.7  NA  \n```\n\n\n:::\n:::\n\n\n\n## Python\n\n:::\n\nThis then allows us to plot the data, for example:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(infections_wide, aes(x = Q1, y = Q2)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE)\n```\n\n::: {.cell-output-display}\n![](trainers-live-demo_files/figure-html/unnamed-chunk-53-1.png){width=672}\n:::\n:::\n\n\n\n## Python\n\n:::\n\n### Back to long format\n\nWe can revert back to a long format with the following:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\npivot_longer(infections_wide,\n             cols = Q1:Q3,           # columns to pivot\n             names_to = \"quarter\",   # column for headings\n             values_to = \"mean_crp\") # column for values\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 534 × 6\n   hospital   infection_type vaccination_status age_group quarter mean_crp\n   <chr>      <chr>          <chr>              <chr>     <chr>      <dbl>\n 1 hospital_1 bacterial      unknown            65+       Q1         23.7 \n 2 hospital_1 bacterial      unknown            65+       Q2         NA   \n 3 hospital_1 bacterial      unknown            65+       Q3         26.8 \n 4 hospital_1 bacterial      unknown            < 18      Q1         25.8 \n 5 hospital_1 bacterial      unknown            < 18      Q2         54.5 \n 6 hospital_1 bacterial      unknown            < 18      Q3         NA   \n 7 hospital_1 bacterial      unvaccinated       18 - 64   Q1          8.35\n 8 hospital_1 bacterial      unvaccinated       18 - 64   Q2         NA   \n 9 hospital_1 bacterial      unvaccinated       18 - 64   Q3         NA   \n10 hospital_1 bacterial      unvaccinated       65+       Q1         23.2 \n# ℹ 524 more rows\n```\n\n\n:::\n:::\n\n\n\n## Python\n\n:::\n\nAnd all is well with the world again.\n\n## DA4: joining data\n\nIn the `infections` data set we have a variable called `hospital`. This contains the following unique entries:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections |> count(hospital)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  hospital       n\n  <chr>      <int>\n1 hospital_1   277\n2 hospital_2   259\n3 hospital_3   280\n4 hospital_4   245\n5 hospital_5   271\n6 <NA>          68\n```\n\n\n:::\n:::\n\n\n## Python\n:::\n\nNote that for some of the `hospital` entries there are missing data. This is relevant later on, when we're joining.\n\nWe're now going to add information on the hospitals, which are stored in `hospital_info.csv`. Let's read in the data:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhospital_info <- read_csv(\"data/hospital_info.csv\")\n```\n:::\n\n\n\n## Python\n:::\n\nLook at the data. There are 6 distinct hospital entries, with additional information for each hospital. We have the following variables:\n\n| Variable           | Type        | Description                                                                 |\n|--------------------|-------------|-----------------------------------------------------------------------------|\n| `hospital`         | character (id) | Unique hospital identifier (`hospital_1` … `hospital_6`).                   |\n| `hospital_name`    | character   | Official hospital name (e.g., *Royal London Hospital*).                     |\n| `location`         | character   | City where the hospital is located (e.g., London, Manchester).              |\n| `bed_capacity`     | integer     | Approximate number of inpatient beds available at the hospital.             |\n| `teaching_hospital`| logical     | Indicates if the hospital is a teaching hospital (`TRUE` / `FALSE`).   |\n\n\n\n### Left join\n\nFirst, we'll add the `hospital_info` data to the `infections` data set. We do this with a left-join. We expect hospital info data to be added to our main `infections` table, if the `hospital` value in `infections` matches with the one in `hospital_info`.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections_left <- left_join(infections, hospital_info, by = \"hospital\")\n```\n:::\n\n\nLet's just select the ID column from `infections`, together with all the columns that have been added.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections_left |> \n  select(patient_id, hospital, hospital_name, location, bed_capacity, teaching_hospital) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  patient_id hospital   hospital_name    location bed_capacity teaching_hospital\n  <chr>      <chr>      <chr>            <chr>           <dbl> <lgl>            \n1 ID_0001    hospital_3 Bristol Royal I… Bristol           768 TRUE             \n2 ID_0002    hospital_3 Bristol Royal I… Bristol           768 TRUE             \n3 ID_0003    hospital_2 Manchester Gene… Manches…          849 FALSE            \n4 ID_0004    hospital_2 Manchester Gene… Manches…          849 FALSE            \n5 ID_0005    hospital_3 Bristol Royal I… Bristol           768 TRUE             \n6 ID_0006    hospital_5 Cardiff Univers… Cardiff           582 TRUE             \n```\n\n\n:::\n:::\n\n\nWe can see that the hospital information is now added to the data. We don't expect any data to have dropped, so the number of observations/rows in `infections_left` should match the original 1400 from `infections`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(infections_left)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1400\n```\n\n\n:::\n:::\n\n\n## Python\n\n:::\n\n### Right join\n\nSo, how does a right join then differ from a left join? Well, here we'd be adding the `infections` data to the `hospital_info` data (so, in the other direction). That means that for each `hospital` value that exists in `hospital_info` it will try and find the values that match the `hospital` column in `infections`.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections_right <- right_join(infections, hospital_info, by = \"hospital\")\n```\n:::\n\n\nAgain, the resulting table contains the data from both `infections` and `hospital_info`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(infections_right)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 15\n  patient_id hospital   quarter infection_type vaccination_status age_group\n  <chr>      <chr>      <chr>   <chr>          <chr>              <chr>    \n1 ID_0001    hospital_3 Q2      none           <NA>               65+      \n2 ID_0002    hospital_3 Q2      viral          <NA>               18 - 64  \n3 ID_0003    hospital_2 Q2      none           unknown            65+      \n4 ID_0004    hospital_2 Q3      fungal         unvaccinated       < 18     \n5 ID_0005    hospital_3 Q2      fungal         vaccinated         65+      \n6 ID_0006    hospital_5 Q3      none           vaccinated         65+      \n# ℹ 9 more variables: icu_admission <lgl>, symptoms_count <dbl>,\n#   systolic_pressure <dbl>, body_temperature <dbl>, crp_level <dbl>,\n#   hospital_name <chr>, location <chr>, bed_capacity <dbl>,\n#   teaching_hospital <lgl>\n```\n\n\n:::\n:::\n\n\nHow many observations do we expect? Let's have a look at how many we've got.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(infections_right)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1333\n```\n\n\n:::\n:::\n\n\n\n## Python\n\n:::\n\nHere we see that we have fewer than the original 1400 observations, because we are joining in the other direction. Remember, there are missing values in our `infections` data set (68 in total). When we're joining `infections` **to** `hospital_info`, these entries get dropped, because there is no missing value entry in the `hospital` column of `hospital_info`.\n\nFor the eagle-eyed amongst you: we have 1333 observations/rows in `infections_right`, whereas there are 68 missing values. We might have expected there to be 1332 rows (the difference between the number of rows in `infections` and the number of missing values), but there are 1333.\n\nWhy? Well, there is one entry in `hospital_info` that does not appear in `infections`: `hospital_6`. When we right join, this value gets retained, so this adds one additional row to the final output.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections_right |> count(hospital)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  hospital       n\n  <chr>      <int>\n1 hospital_1   277\n2 hospital_2   259\n3 hospital_3   280\n4 hospital_4   245\n5 hospital_5   271\n6 hospital_6     1\n```\n\n\n:::\n:::\n\n\n\n## Python\n\n:::\n\nIf we wouldn't want that, we'd use inner join.\n\n### Inner join\n\nInner join will join two tables and only retain values (based on the joining ID) that exist in *both* tables.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections_inner <- inner_join(infections, hospital_info, by = \"hospital\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(infections_inner)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1332\n```\n\n\n:::\n:::\n\n\nOnly the 5 hospitals that appear in the `infections` data set are retained:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections_inner |> count(hospital)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  hospital       n\n  <chr>      <int>\n1 hospital_1   277\n2 hospital_2   259\n3 hospital_3   280\n4 hospital_4   245\n5 hospital_5   271\n```\n\n\n:::\n:::\n\n\n\n## Python\n\n:::\n\nThis is entirely expected, since we don't have missing data in `hospital_info` (so all the missing data from `infections` are dropped), nor do we have a `hospital_6` entry in `infections` (so that is dropped too).\n\n### Full join\n\nIf we wanted to retain *all* observations, regardless of which table they're from, we'd use a full join.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections_full <- full_join(infections, hospital_info, by = \"hospital\")\n```\n:::\n\n\nHow many rows do we expect? Well, the 1400 from `infections` plus the one extra (`hospital_6` entry) from `hospital_info`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(infections_full)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1401\n```\n\n\n:::\n:::\n\n\nWe can check that we've retained all values, by counting the number of observations for each `hospital` value:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfections_full |> count(hospital)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 2\n  hospital       n\n  <chr>      <int>\n1 hospital_1   277\n2 hospital_2   259\n3 hospital_3   280\n4 hospital_4   245\n5 hospital_5   271\n6 hospital_6     1\n7 <NA>          68\n```\n\n\n:::\n:::\n\n\n\n## Python\n\n:::\n\nWe see that **all** `hospital` values are retained, including the missing values *and* the one `hospital_6` value coming from the `hospital_info` data set. Success!\n",
    "supporting": [
      "trainers-live-demo_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}