{
  "hash": "8d1b5577a08171f9b275c793c664ca78",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Manipulating rows\n---\n\n::: {.callout-tip}\n#### Learning objectives\n\n- Learn to order and arrange rows\n- Be able to find and retain unique rows\n- Understand how logical operators are used\n- Implement conditional statements to filter specific data\n- Be able to identify and decide how to deal with missing data\n\n:::\n\n\n## Context\n\nData sets can contain large quantities of observations. Often we are only interested in part of the data at a given time. We can deal with this by manipulating rows.\n\n## Section setup {#setup_manipulating_rows}\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe'll continue this section with the script named `07-manipulating-rows.R`. If needed, add the following code to the top of your script and run it.\n\nIn this section we will use a new package, called `naniar`, to visualise where we have missing data. Install it as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install if needed\ninstall.packages(\"naniar\")\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A collection of R packages designed for data science\nlibrary(tidyverse)\n\n# Package to visualise missing data\nlibrary(naniar)\n\nsurveys <- read_csv(\"data/surveys.csv\")\n```\n:::\n\n\n## Python\n\nWe'll continue this section with the script named `07-manipulating-rows.py`.\n\nWe'll use a new package, so install if needed from the terminal:\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nconda install conda-forge::missingno\n```\n:::\n\n\nThen, if needed, add the following code to the top of your script and run it.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# A Python data analysis and manipulation tool\nimport pandas as pd\n\n# Python equivalent of `ggplot2`\nfrom plotnine import *\n\n# Load missingno\nimport missingno as msno\n\nsurveys = pd.read_csv(\"data/surveys.csv\")\n```\n:::\n\n\n:::\n:::\n\n\n## Manipulation of observations\n\n### Ordering rows\nWe often want to order data in a certain way, for example ordering by date or in alphabetically. The example below illustrates how we would order data based on `weight`:\n\n::: {.carousel data-caption=\"Ordering by weight in ascending order (click to toggle).\"}\n\n![](images/manipulation-order_main.png)\n![](images/manipulation-order_weight.png)\n:::\n\nLet's illustrate this with the `surveys` data set, arranging the data based on `year`.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys |> \n  arrange(year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 9\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>  <dbl>\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2         2     7    16  1977       3 NL         M                  33     NA\n 3         3     7    16  1977       2 DM         F                  37     NA\n 4         4     7    16  1977       7 DM         M                  36     NA\n 5         5     7    16  1977       3 DM         M                  35     NA\n 6         6     7    16  1977       1 PF         M                  14     NA\n 7         7     7    16  1977       2 PE         F                  NA     NA\n 8         8     7    16  1977       1 DM         M                  37     NA\n 9         9     7    16  1977       1 DM         F                  34     NA\n10        10     7    16  1977       6 PF         F                  20     NA\n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\nIf we'd want to arrange the data in *descending* order (most recent to oldest), we would employ the `desc()` helper function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys |> \n  arrange(desc(year))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 9\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>  <dbl>\n 1     33321     1    12  2002       1 DM         M                  38     44\n 2     33322     1    12  2002       1 DO         M                  37     58\n 3     33323     1    12  2002       1 PB         M                  28     45\n 4     33324     1    12  2002       1 AB         <NA>               NA     NA\n 5     33325     1    12  2002       1 DO         M                  35     29\n 6     33326     1    12  2002       2 OT         F                  20     26\n 7     33327     1    12  2002       2 OT         M                  20     24\n 8     33328     1    12  2002       2 OT         F                  21     22\n 9     33329     1    12  2002       2 DM         M                  37     47\n10     33330     1    12  2002       2 DO         M                  35     51\n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\nWe can read that bit of code as \"take the `surveys` data set, send it to the `arrange()` function and ask it to arrange the data in descending order (using `desc()`) based on the `year` column\".\n\nWe can also combine this approach with multiple variables, for example arranging data based on descending year *and* (ascending) hindfoot length:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys |> \n  arrange(desc(year), hindfoot_length)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 9\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>  <dbl>\n 1     33647     3    14  2002       3 PF         M                   9      8\n 2     35301    12     8  2002       4 PF         M                  13      6\n 3     35506    12    31  2002       6 PF         M                  13      8\n 4     34281     6    15  2002      23 RM         F                  14      9\n 5     34663     7    14  2002      16 RM         M                  14      7\n 6     35101    11    10  2002       9 PF         M                  14      7\n 7     35487    12    29  2002      23 RO         F                  14     13\n 8     33429     2     9  2002       3 PF         M                  15      8\n 9     33535     2    10  2002      13 PF         F                  15      7\n10     33556     2    10  2002       5 RO         M                  15      9\n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.sort_values(by = \"year\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  month  day  year  ...  species_id  sex hindfoot_length  weight\n0              1      7   16  1977  ...          NL    M            32.0     NaN\n343          344     10   18  1977  ...          NL  NaN             NaN     NaN\n342          343     10   18  1977  ...          PF  NaN             NaN     NaN\n341          342     10   18  1977  ...          DM    M            34.0    25.0\n340          341     10   18  1977  ...          DS    M            50.0     NaN\n...          ...    ...  ...   ...  ...         ...  ...             ...     ...\n34063      34064      5   16  2002  ...          PP    F            23.0    18.0\n34064      34065      5   16  2002  ...          DO    M            36.0    32.0\n34065      34066      5   16  2002  ...          DO    M            37.0    29.0\n34059      34060      5   16  2002  ...          DM    M            36.0    55.0\n35548      35549     12   31  2002  ...         NaN  NaN             NaN     NaN\n\n[35549 rows x 9 columns]\n```\n\n\n:::\n:::\n\n\nIf we'd want to arrange the data in *descending* order (most recent to oldest), we would specify this with the `ascending = False` argument:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.sort_values(by = \"year\", ascending = False)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  month  day  year  ...  species_id  sex hindfoot_length  weight\n35548      35549     12   31  2002  ...         NaN  NaN             NaN     NaN\n34060      34061      5   16  2002  ...          PB    M            27.0    37.0\n34066      34067      5   16  2002  ...          DM    F            36.0    50.0\n34065      34066      5   16  2002  ...          DO    M            37.0    29.0\n34064      34065      5   16  2002  ...          DO    M            36.0    32.0\n...          ...    ...  ...   ...  ...         ...  ...             ...     ...\n341          342     10   18  1977  ...          DM    M            34.0    25.0\n342          343     10   18  1977  ...          PF  NaN             NaN     NaN\n343          344     10   18  1977  ...          NL  NaN             NaN     NaN\n344          345     11   12  1977  ...          DM    F            34.0    45.0\n0              1      7   16  1977  ...          NL    M            32.0     NaN\n\n[35549 rows x 9 columns]\n```\n\n\n:::\n:::\n\n\nWe can also combine this approach with multiple variables, for example arranging data based on descending year *and* (ascending) hindfoot length:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.sort_values(\n    by = [\"year\", \"hindfoot_length\"],\n    ascending = [False, True]\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  month  day  year  ...  species_id  sex hindfoot_length  weight\n33646      33647      3   14  2002  ...          PF    M             9.0     8.0\n35300      35301     12    8  2002  ...          PF    M            13.0     6.0\n35505      35506     12   31  2002  ...          PF    M            13.0     8.0\n34280      34281      6   15  2002  ...          RM    F            14.0     9.0\n34662      34663      7   14  2002  ...          RM    M            14.0     7.0\n...          ...    ...  ...   ...  ...         ...  ...             ...     ...\n494          495     12   11  1977  ...          NL  NaN             NaN     NaN\n496          497     12   11  1977  ...          OT  NaN             NaN     NaN\n499          500     12   11  1977  ...          OT  NaN             NaN     NaN\n500          501     12   11  1977  ...          OT  NaN             NaN     NaN\n502          503     12   11  1977  ...         NaN  NaN             NaN     NaN\n\n[35549 rows x 9 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\n### Finding unique values\n\nSometimes it is useful to retain rows with unique combinations of some of our variables (i.e. remove any duplicated rows). \n\n::: {.panel-tabset group=\"language\"}\n## R\n\nThis can be done with the `distinct()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys |> \n  distinct(species_id, year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 535 × 2\n   species_id  year\n   <chr>      <dbl>\n 1 NL          1977\n 2 DM          1977\n 3 PF          1977\n 4 PE          1977\n 5 DS          1977\n 6 PP          1977\n 7 SH          1977\n 8 OT          1977\n 9 DO          1977\n10 OX          1977\n# ℹ 525 more rows\n```\n\n\n:::\n:::\n\n\n\n## Python\n\nWe can do this by specifying which column we'd like to get the unique values from (here, we're using `species_id` and `year` as an example). We then use `.drop_duplicates()` to remove all the duplicate values:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys[[\"species_id\", \"year\"]].drop_duplicates()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      species_id  year\n0             NL  1977\n2             DM  1977\n5             PF  1977\n6             PE  1977\n10            DS  1977\n...          ...   ...\n34574         UR  2002\n34778         OL  2002\n35032         SF  2002\n35510         DX  2002\n35511         US  2002\n\n[535 rows x 2 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\n### Filtering by condition\nOften we want to filter our data based on specific conditions / properties in the data. For example, in our data set you might want to filter for certain years, a specific weight range or only get all the observations for the first 100 record IDs.\n\nBefore we delve into this, it is important to understand that when we set a condition like above, the output \nis a _logical vector_. Let's see an example using a small vector.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsome_years <- c(1985, 1990, 1999, 1995, 2010, 2000)\nsome_years < 2000\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n## Python\n\nFor this example we'll keep using Pandas, for consistency. Since we're only dealing with a simple, one-dimensional bunch of data, we create a `Series`:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsome_years = pd.Series([1985, 1990, 1999, 1995, 2010, 2000])\nresult = some_years < 2000\n\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0     True\n1     True\n2     True\n3     True\n4    False\n5    False\ndtype: bool\n```\n\n\n:::\n:::\n\n\n:::\n\nIt is possible to combine several conditions by using the _logical operators_ \n`&` (AND) and `|` (OR). For example, if we wanted the years between 1990 and 2000:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# both conditions have to be true\nsome_years > 1990 & some_years < 2000\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nAnd if we wanted the years below 1990 or above 2000, then:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# only one or the other of the conditions has to be true\nsome_years < 1990 | some_years > 2000\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nresult = (some_years > 1990) & (some_years < 2000)\n\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0    False\n1    False\n2     True\n3     True\n4    False\n5    False\ndtype: bool\n```\n\n\n:::\n:::\n\n\nAnd if we wanted the years below 1990 or above 2000, then:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nresult = (some_years < 1990) | (some_years > 2000)\n\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0     True\n1    False\n2    False\n3    False\n4     True\n5    False\ndtype: bool\n```\n\n\n:::\n:::\n\n\n:::\n\nThis concept is also applied to tables. We could filter across all rows in the `surveys` data set, for a `hindfoot_length` of larger than 31 mm:\n\n![The logic behind filtering: for each row the condition is checked (here: `hindfoot_length > 31`). If the outcome is `TRUE` then the row is returned.](images/manipulation-filter_rows.png){#fig-manipulation_filter_rows}\n\nWe could then do this as follows:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys |> \n  filter(hindfoot_length > 31)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15,729 × 9\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>  <dbl>\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2         2     7    16  1977       3 NL         M                  33     NA\n 3         3     7    16  1977       2 DM         F                  37     NA\n 4         4     7    16  1977       7 DM         M                  36     NA\n 5         5     7    16  1977       3 DM         M                  35     NA\n 6         8     7    16  1977       1 DM         M                  37     NA\n 7         9     7    16  1977       1 DM         F                  34     NA\n 8        11     7    16  1977       5 DS         F                  53     NA\n 9        12     7    16  1977       7 DM         M                  38     NA\n10        13     7    16  1977       3 DM         M                  35     NA\n# ℹ 15,719 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys[surveys[\"hindfoot_length\"] > 31]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  month  day  year  ...  species_id sex hindfoot_length  weight\n0              1      7   16  1977  ...          NL   M            32.0     NaN\n1              2      7   16  1977  ...          NL   M            33.0     NaN\n2              3      7   16  1977  ...          DM   F            37.0     NaN\n3              4      7   16  1977  ...          DM   M            36.0     NaN\n4              5      7   16  1977  ...          DM   M            35.0     NaN\n...          ...    ...  ...   ...  ...         ...  ..             ...     ...\n35533      35534     12   31  2002  ...          DM   M            37.0    56.0\n35534      35535     12   31  2002  ...          DM   M            37.0    53.0\n35535      35536     12   31  2002  ...          DM   F            35.0    42.0\n35536      35537     12   31  2002  ...          DM   F            36.0    46.0\n35547      35548     12   31  2002  ...          DO   M            36.0    51.0\n\n[15729 rows x 9 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\nThis then only keeps the observations where `hindfoot_length > 31`, in this case \n15729 observations.\n\n::: {.callout-important}\n## Conditional  operators\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nTo set filtering conditions, use the following _relational operators_:\n \n- `>` is greater than\n- `>=` is greater than or equal to\n- `<` is less than\n- `<=` is less than or equal to\n- `==` is equal to\n- `!=` is different from\n- `%in%` is contained in\n\nTo combine conditions, use the following _logical operators_:\n\n- `&` AND\n- `|` OR\n \nSome functions return logical results and can be used in filtering operations:\n \n- `is.na(x)` returns _TRUE_ if a value in _x_ is missing\n\nThe `!` can be used to negate a logical condition:\n\n- `!is.na(x)` returns _TRUE_ if a value in _x_ is NOT missing\n- `!(x %in% y)` returns _TRUE_ if a value in _x_ is NOT present in _y_\n\n## Python\n\nTo set filtering conditions, use the following _relational operators_:\n \n- `>` is greater than\n- `>=` is greater than or equal to\n- `<` is less than\n- `<=` is less than or equal to\n- `==` is equal to\n- `!=` is different from\n- `.isin([...])` is contained in\n\nTo combine conditions, use the following _logical operators_:\n\n- `&` AND\n- `|` OR\n \nSome functions return logical results and can be used in filtering operations:\n \n- `df[\"x\"].isna()` returns _True_ if a value in _x_ is missing\n\nThe `~` (bitwise NOT) can be used to negate a logical condition:\n\n- `~df[\"x\"].isna()` returns _True_ if a value in _x_ is NOT missing\n- `~df[\"x\"].isin([\"y\"])` returns _True_ if a value in _x_ is NOT present in `\"y\"`\n:::\n\n:::\n\n### Missing data revisited {#missingdata-revisited}\n\nIt's important to carefully consider how to deal with missing data, as we\n[have previously seen](#missing-data). It's easy enough to filter out all rows that contain missing data, however this is rarely the best course of action, because you might accidentally throw out useful data in columns that you'll need later.\n\nFurthermore, it's often a good idea to see if there is any **structure** in your missing data. Maybe certain variables are consistently absent, which could tell you something about your data.\n\n::: {.panel-tabset group=\"language\"}\n\n## R\n\nWe could filter out all the missing `weight` values as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys |> \n  filter(!is.na(weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 32,283 × 9\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>  <dbl>\n 1        63     8    19  1977       3 DM         M                  35     40\n 2        64     8    19  1977       7 DM         M                  37     48\n 3        65     8    19  1977       4 DM         F                  34     29\n 4        66     8    19  1977       4 DM         F                  35     46\n 5        67     8    19  1977       7 DM         M                  35     36\n 6        68     8    19  1977       8 DO         F                  32     52\n 7        69     8    19  1977       2 PF         M                  15      8\n 8        70     8    19  1977       3 OX         F                  21     22\n 9        71     8    19  1977       7 DM         F                  36     35\n10        74     8    19  1977       8 PF         M                  12      7\n# ℹ 32,273 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.dropna(subset=[\"weight\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  month  day  year  ...  species_id sex hindfoot_length  weight\n62            63      8   19  1977  ...          DM   M            35.0    40.0\n63            64      8   19  1977  ...          DM   M            37.0    48.0\n64            65      8   19  1977  ...          DM   F            34.0    29.0\n65            66      8   19  1977  ...          DM   F            35.0    46.0\n66            67      8   19  1977  ...          DM   M            35.0    36.0\n...          ...    ...  ...   ...  ...         ...  ..             ...     ...\n35540      35541     12   31  2002  ...          PB   F            24.0    31.0\n35541      35542     12   31  2002  ...          PB   F            26.0    29.0\n35542      35543     12   31  2002  ...          PB   F            27.0    34.0\n35546      35547     12   31  2002  ...          RM   F            15.0    14.0\n35547      35548     12   31  2002  ...          DO   M            36.0    51.0\n\n[32283 rows x 9 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.panel-tabset group=\"language\"}\n\n## R\n\nWe can combine this for multiple columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys |> \n  filter(!is.na(weight) & !is.na(hindfoot_length))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 30,738 × 9\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>  <dbl>\n 1        63     8    19  1977       3 DM         M                  35     40\n 2        64     8    19  1977       7 DM         M                  37     48\n 3        65     8    19  1977       4 DM         F                  34     29\n 4        66     8    19  1977       4 DM         F                  35     46\n 5        67     8    19  1977       7 DM         M                  35     36\n 6        68     8    19  1977       8 DO         F                  32     52\n 7        69     8    19  1977       2 PF         M                  15      8\n 8        70     8    19  1977       3 OX         F                  21     22\n 9        71     8    19  1977       7 DM         F                  36     35\n10        74     8    19  1977       8 PF         M                  12      7\n# ℹ 30,728 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.dropna(subset = [\"weight\", \"hindfoot_length\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  month  day  year  ...  species_id sex hindfoot_length  weight\n62            63      8   19  1977  ...          DM   M            35.0    40.0\n63            64      8   19  1977  ...          DM   M            37.0    48.0\n64            65      8   19  1977  ...          DM   F            34.0    29.0\n65            66      8   19  1977  ...          DM   F            35.0    46.0\n66            67      8   19  1977  ...          DM   M            35.0    36.0\n...          ...    ...  ...   ...  ...         ...  ..             ...     ...\n35540      35541     12   31  2002  ...          PB   F            24.0    31.0\n35541      35542     12   31  2002  ...          PB   F            26.0    29.0\n35542      35543     12   31  2002  ...          PB   F            27.0    34.0\n35546      35547     12   31  2002  ...          RM   F            15.0    14.0\n35547      35548     12   31  2002  ...          DO   M            36.0    51.0\n\n[30738 rows x 9 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\nWe can also combine that with other filters.\n\n::: {.panel-tabset group=\"language\"}\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys |> \n  filter(!is.na(weight) & !is.na(hindfoot_length)) |> \n  filter(hindfoot_length > 40)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,045 × 9\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>  <dbl>\n 1       357    11    12  1977       9 DS         F                  50    117\n 2       362    11    12  1977       1 DS         F                  51    121\n 3       367    11    12  1977      20 DS         M                  51    115\n 4       377    11    12  1977       9 DS         F                  48    120\n 5       381    11    13  1977      17 DS         F                  48    118\n 6       383    11    13  1977      11 DS         F                  52    126\n 7       385    11    13  1977      17 DS         M                  50    132\n 8       392    11    13  1977      11 DS         F                  53    122\n 9       394    11    13  1977       4 DS         F                  48    107\n10       398    11    13  1977       4 DS         F                  50    115\n# ℹ 2,035 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\nTo do this, we might prefer to use a slightly syntax: the `.notna()`. This allows us to chain operations a bit cleaner, making our code easier to read:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys[\n    (surveys[\"weight\"].notna()) &\n    (surveys[\"hindfoot_length\"].notna()) &\n    (surveys[\"hindfoot_length\"] > 40)\n]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  month  day  year  ...  species_id sex hindfoot_length  weight\n356          357     11   12  1977  ...          DS   F            50.0   117.0\n361          362     11   12  1977  ...          DS   F            51.0   121.0\n366          367     11   12  1977  ...          DS   M            51.0   115.0\n376          377     11   12  1977  ...          DS   F            48.0   120.0\n380          381     11   13  1977  ...          DS   F            48.0   118.0\n...          ...    ...  ...   ...  ...         ...  ..             ...     ...\n29572      29573      5   15  1999  ...          DS   M            50.0    96.0\n29705      29706      6   12  1999  ...          DS   M            49.0   102.0\n30424      30425      3    4  2000  ...          DO   F            64.0    35.0\n30980      30981      7    1  2000  ...          DO   F            42.0    46.0\n33367      33368      1   12  2002  ...          PB   M            47.0    27.0\n\n[2045 rows x 9 columns]\n```\n\n\n:::\n:::\n\n:::\n\nOften it's not that easy to get a sense of how missing data are distributed in the data set. We can use summary statistics and visualisations to get a better sense.\n\n::: {.panel-tabset group=\"language\"}\n\n## R\n\nThe easiest way of getting some numbers on the missing data is by using the `summary()` function, which will report the number of `NA`'s for each column (for example: see the `hindfoot_length` column):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(surveys)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   record_id         month             day             year         plot_id    \n Min.   :    1   Min.   : 1.000   Min.   : 1.00   Min.   :1977   Min.   : 1.0  \n 1st Qu.: 8888   1st Qu.: 4.000   1st Qu.: 9.00   1st Qu.:1984   1st Qu.: 5.0  \n Median :17775   Median : 6.000   Median :16.00   Median :1990   Median :11.0  \n Mean   :17775   Mean   : 6.478   Mean   :15.99   Mean   :1990   Mean   :11.4  \n 3rd Qu.:26662   3rd Qu.:10.000   3rd Qu.:23.00   3rd Qu.:1997   3rd Qu.:17.0  \n Max.   :35549   Max.   :12.000   Max.   :31.00   Max.   :2002   Max.   :24.0  \n                                                                               \n  species_id            sex            hindfoot_length     weight      \n Length:35549       Length:35549       Min.   : 2.00   Min.   :  4.00  \n Class :character   Class :character   1st Qu.:21.00   1st Qu.: 20.00  \n Mode  :character   Mode  :character   Median :32.00   Median : 37.00  \n                                       Mean   :29.29   Mean   : 42.67  \n                                       3rd Qu.:36.00   3rd Qu.: 48.00  \n                                       Max.   :70.00   Max.   :280.00  \n                                       NA's   :4111    NA's   :3266    \n```\n\n\n:::\n:::\n\n\nOften it's nice to visualise where your missing values are, to see if there are any patterns that are obvious. There are several packages in R that can do this, of which `naniar` is one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install if needed\ninstall.packages(\"naniar\")\n\n# load the library\nlibrary(naniar)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# visualise missing data\nvis_miss(surveys)\n```\n\n::: {.cell-output-display}\n![](07-manipulating-rows_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n## Python\n\nThe easiest way of counting the number of missing values in Python is by combining `.isna()` and `.sum()`:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# count missing values\nsurveys.isna().sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nrecord_id             0\nmonth                 0\nday                   0\nyear                  0\nplot_id               0\nspecies_id          763\nsex                2511\nhindfoot_length    4111\nweight             3266\ndtype: int64\n```\n\n\n:::\n:::\n\n\nOften it's nice to visualise where your missing values are, to see if there are any patterns that are obvious. There are several packages in Python that can do this, of which `missingno` is one.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport missingno as msno\n```\n:::\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# visual matrix\nmsno.matrix(surveys)\n```\n\n::: {.cell-output-display}\n![](07-manipulating-rows_files/figure-html/unnamed-chunk-32-1.png){width=2400}\n:::\n:::\n\n\n:::\n\n\n## Summary\n\n::: {.callout-tip}\n#### Key points\n\n::: {.panel-tabset group=\"language\"}\n\n## R\n\n- We use the `arrange()` function to order data, and can reverse the order using `desc()`.\n- Unique rows can be retained with `distinct()`.\n- We use `filter()` to choose rows based on conditions.\n- Conditions can be set using several operators: `>`, `>=`, `<`, `<=`, `==`, `!=`, `%in%`.\n- Conditions can be combined using `&` (AND) and `|` (OR).\n- The function `is.na()` can be used to identify missing values. It can be negated as `!is.na()` to find non-missing values.\n- We can visualise missing data using the `vis_miss()` function from the `naniar` package.\n\n## Python\n\n- We can use the `.sort_values()` method to order data, specifying the `ascending =` argument as `True` or `False` to control the order.\n- The `.drop_duplicates()` method allows us to retain unique rows.\n- We use subsetting (e.g. `surveys[surveys[\"hindfoot_length\"] > 31]`) together with conditions to filter data.\n-- Conditions can be set using several operators: `>`, `>=`, `<`, `<=`, `==`, `!=`, `.isin([...])`.\n- Conditions can be combined using `&` (AND) and `|` (OR).\n- The function `.isna()` can be used to identify missing values. It can be negated using `~` to find non-missing values (e.g. `surveys[~surveys[\"weight\"].isna()]`.\n- We can visualise missing data using the `msno.matrix` function from the `missingno` package.\n\n:::\n\n:::\n",
    "supporting": [
      "07-manipulating-rows_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}