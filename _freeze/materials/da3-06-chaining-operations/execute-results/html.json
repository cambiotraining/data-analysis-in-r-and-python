{
  "hash": "ac437549f2d393873af54b6fed5fb88f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Chaining operations\n---\n\n::: {.callout-tip}\n#### Learning objectives\n\n- Learn how to chain operations together.\n:::\n\n## Context\n\nIn the section above we performed several operations on a single data set. Often there is a sequence to this, where the output of one operation gets fed into the next. We can simplify this by chaining commands.\n\n## Section setup {#setup_chaining_operations}\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe'll continue this section with the script named `da3-06-chaining-operations.R`. If needed, add the following code to the top of your script and run it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A collection of R packages designed for data science\nlibrary(tidyverse)\n\nsurveys <- read_csv(\"data/surveys.csv\")\n```\n:::\n\n\n## Python\n\nWe'll continue this section with the Notebook named `da3-06-chaining-operations.ipynb`. Add the following code to the first cell and run it.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# A Python data analysis and manipulation tool\nimport pandas as pd\n\n# Python equivalent of `ggplot2`\nfrom plotnine import *\n\nsurveys = pd.read_csv(\"data/surveys.csv\")\n```\n:::\n\n\n:::\n\n## Pipes or chaining commands\n\nSo far, we've used single operations when we were manipulating our data. For example, we can select columns with:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(surveys, record_id, hindfoot_length)\n```\n:::\n\n\nLet's say we wanted combine that with creating a new column, for example hindfoot length in centimeters.\n\nWe would have to do the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# grab the relevant columns and store in a new object\nsubset_surveys <- select(surveys, record_id, hindfoot_length)\n\n# create the new column\nmutate(subset_surveys, hindfoot_length_cm = hindfoot_length / 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 3\n   record_id hindfoot_length hindfoot_length_cm\n       <dbl>           <dbl>              <dbl>\n 1         1              32                3.2\n 2         2              33                3.3\n 3         3              37                3.7\n 4         4              36                3.6\n 5         5              35                3.5\n 6         6              14                1.4\n 7         7              NA               NA  \n 8         8              37                3.7\n 9         9              34                3.4\n10        10              20                2  \n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\nWe had to create a new *object* (here, called `subset_surveys`) to store the intermediate data we were interested in, and then continue with creating the new column.\n\nThis clutters up your computer's memory rather quickly when dealing with lots of data. A much better way is that we **pipe** or **chain** one after the other. To do this, we *start with the data* and use a pipe symbol (`|>` or `%>%`) as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys |> \n  select(record_id, hindfoot_length) |>\n  mutate(hindfoot_length_cm = hindfoot_length / 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 3\n   record_id hindfoot_length hindfoot_length_cm\n       <dbl>           <dbl>              <dbl>\n 1         1              32                3.2\n 2         2              33                3.3\n 3         3              37                3.7\n 4         4              36                3.6\n 5         5              35                3.5\n 6         6              14                1.4\n 7         7              NA               NA  \n 8         8              37                3.7\n 9         9              34                3.4\n10        10              20                2  \n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\nAn easy way of remembering what the pipe does is to replace (in your head) the pipe symbol with the phrase \"and then...\".\n\nSo, we `select()` the `record_id` and `hindfoot_length` columns *and then* use `mutate()` to create a new column called `hindfoot_length_cm`.\n\n::: {.callout-note}\n## Which pipe symbol do I use?\n\nYou'll find that people use two pipe symbols quite interchangeably in R: the `|>` pipe (native, built-in R) and `%>%` from the `magrittr` package.\n\nThe native, built-in pipe is a rather new addition, since version 4.1. It is slightly different in its behaviour than the `%>%` pipe (if you want to know more, see [here](https://ivelasq.rbind.io/blog/understanding-the-r-pipe/#:~:text=A%20while%20back%2C%20I%20wrote,available%20since%20R%20version%204.1.)), but for most purposes they work the same.\n\nWe tend to use the native, built-in pipe throughout the materials. But the `magrittr` pipe works just as well! You can change your preference in RStudio by going to `Tools > Global options > Code` and changing the tickbox enabling/disabling the native pipe operator.\n\n:::\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys[[\"record_id\", \"hindfoot_length\"]].copy()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  hindfoot_length\n0              1             32.0\n1              2             33.0\n2              3             37.0\n3              4             36.0\n4              5             35.0\n...          ...              ...\n35544      35545              NaN\n35545      35546              NaN\n35546      35547             15.0\n35547      35548             36.0\n35548      35549              NaN\n\n[35549 rows x 2 columns]\n```\n\n\n:::\n:::\n\n\nLet's say we wanted combine that with creating a new column, for example hindfoot length in centimeters.\n\nWe would have to do the following:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# select the required columns and store in a new data set\nsubset_surveys = surveys[[\"record_id\", \"hindfoot_length\"]].copy()\n\n# take the new data set and calculate the new column\nsubset_surveys[\"hindfoot_length_cm\"] = subset_surveys[\"hindfoot_length\"] / 10\n```\n:::\n\n\nWe had to create a new *object* (here, called `subset_surveys`) to store the intermediate data we were interested in, and then continue with creating the new column.\n\nThis clutters up your computer's memory rather quickly when dealing with lots of data. So, it'd be good if we could **pipe** or **chain** these commands, like we can do in R.\n\nPython does not have an exact equivalent to pipes in R, but you can chain methods in `pandas`, which can make your life a lot easier. Let's explore that a bit further.\n\nIn the code below we are using `.loc[:, [\"col1\", \"col2\"]]` to select columns. This is a bit more chain-friendly than using `[[\"col1\", \"col2\"]]` because it also allows filtering (more on this in the next chapter).\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(\n  surveys\n  .loc[:, ['record_id', 'hindfoot_length']]\n  .assign(hindfoot_length_cm = lambda df: df[\"hindfoot_length\"] / 10)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  hindfoot_length  hindfoot_length_cm\n0              1             32.0                 3.2\n1              2             33.0                 3.3\n2              3             37.0                 3.7\n3              4             36.0                 3.6\n4              5             35.0                 3.5\n...          ...              ...                 ...\n35544      35545              NaN                 NaN\n35545      35546              NaN                 NaN\n35546      35547             15.0                 1.5\n35547      35548             36.0                 3.6\n35548      35549              NaN                 NaN\n\n[35549 rows x 3 columns]\n```\n\n\n:::\n:::\n\n\nHere, we do the following:\n\n* `.loc[:, ['record_id', 'hindfoot_length']]` selects the columns you want\n* `.assign(...)` then creates a new column\n* `lambda df` tells `pandas` to compute the new column using the current data frame in the chain\n\n::: {.callout-important}\n## Oh, `lambda`!\n\n**Why Use `lambda` in Pandas `.assign()`?**\n\nIn Python, a `lambda` is an **anonymous function** — a quick, in-place function without a name.\n\n**Why is `lambda` important in method chaining?**\n\nThis all relates to the evaluation order: `.assign()` evaluates its arguments **before** the previous steps in the chain are fully applied.\n\nSo if you reference a column that was renamed or created earlier in the chain, `pandas` won’t find it unless you use `lambda` to delay evaluation.\n\nUsing `lambda` in `.assign()` ensures that pandas waits to evaluate the new column **until the DataFrame is fully updated** by the earlier steps.\n\nSuppose we want to:\n\n- Select two columns\n- Create a new column `weight_kg` as `weight_g / 1000`\n\nWithout `lambda` — this will raise an error:\n\n```python\n(\n  surveys\n  .loc[:, [\"record_id\", \"weight\"]]\n  .assign(weight_kg = surveys[\"weight_g\"] / 1000)  # KeyError: \"weight_g\"\n)\n```\n:::\n\n::: {.callout-note}\n## Pipe-style packages in Python\n\nThere are some `dplyr`-style implementations in Python, that also include a pipe. One is [siuba](https://github.com/machow/siuba) but it does not seem to be actively maintained. Another one is [dfply](https://github.com/kieferk/dfply), which has not been updated for 7 years and counting...\n\nSo, rather than being frustrated about this, I suggest we accept the differences between the two languages and move on! :-)\n:::\n\n:::\n\n## Chaining different commands\n\nWe can extend this concept a bit further, beyond just the creation of new columns.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys |> \n  select(record_id, weight) |>  # select columns\n  rename(weight_g = weight) |>  # rename weight\n  head()                        # show the first few rows\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  record_id weight_g\n      <dbl>    <dbl>\n1         1       NA\n2         2       NA\n3         3       NA\n4         4       NA\n5         5       NA\n6         6       NA\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(\n  surveys\n  .loc[:, ['record_id', 'weight']]          # select columns\n  .rename(columns = {'weight': 'weight_g'}) # rename column\n  .head()                                   # show first few rows\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   record_id  weight_g\n0          1       NaN\n1          2       NaN\n2          3       NaN\n3          4       NaN\n4          5       NaN\n```\n\n\n:::\n:::\n\n\n:::\n\n## Exercises\n\n### Chaining {#sec-exr_chaining}\n\n::: {.callout-exercise #ex-chaining}\n#### Chaining\n\n{{< level 1 >}}\n\nFor this exercise we'll be using the data from `data/parasites.csv`.\n\nThe `fish_length` variable is the length of the fish measured in centimeters. Do the following:\n\n* select all but the `parasite_count` column\n* rename the `fish_length` column to `fish_length_cm`\n* create a new column that contains the fish length in inches (divide by `2.54`)\n* do all of this in a single chain\n\n::: {.callout-answer collapse=\"true\"}\n\nLoad the data, if needed.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparasites <- read_csv(\"data/parasites.csv\")\n```\n:::\n\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nparasites = pd.read_csv(\"data/parasites.csv\")\n```\n:::\n\n\n:::\n\nPerform chaining operations:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparasites |> \n  select(lake, fish_length) |> \n  rename(fish_length_cm = fish_length) |> \n  mutate(fish_length_in = fish_length_cm / 2.54)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 64 × 3\n   lake  fish_length_cm fish_length_in\n   <chr>          <dbl>          <dbl>\n 1 C               21.1           8.31\n 2 C               26.4          10.4 \n 3 C               18.9           7.44\n 4 B               27.2          10.7 \n 5 C               29            11.4 \n 6 B               24.2           9.53\n 7 B               31.2          12.3 \n 8 B               20.3           7.99\n 9 C               27            10.6 \n10 A               27            10.6 \n# ℹ 54 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(\n  parasites\n  .loc[:, [\"lake\", \"fish_length\"]]\n  .rename(columns = {\"fish_length\": \"fish_length_cm\"})\n  .assign(fish_length_in = lambda df: df[\"fish_length_cm\"] / 2.54)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   lake  fish_length_cm  fish_length_in\n0     C            21.1        8.307087\n1     C            26.4       10.393701\n2     C            18.9        7.440945\n3     B            27.2       10.708661\n4     C            29.0       11.417323\n..  ...             ...             ...\n59    B            26.5       10.433071\n60    A            24.6        9.685039\n61    C            27.1       10.669291\n62    A            25.9       10.196850\n63    C            33.9       13.346457\n\n[64 rows x 3 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\n:::\n:::\n\n## Summary\n\n::: {.callout-tip}\n#### Key points\n\n- In Python we use method chaining, which apply a series of transformations to a `pandas` DataFrame.\n- In R we have dedicated pipe symbols and we can use `|>` (built-in) or `%>%` (via `magrittr` package) to chain operations.\n- Both of these approaches allow us to run multiple lines of code sequentially, simplifying pipelines and making them easier to read.\n:::\n",
    "supporting": [
      "da3-06-chaining-operations_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}