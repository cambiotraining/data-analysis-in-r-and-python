{
  "hash": "da7ecf232c9747d9c62e74dc6a0d3d27",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Manipulating columns\n---\n\n::: {.callout-tip}\n#### Learning objectives\n\n- Learn how to select and/or rename specific columns from a data frame.\n- Be able to create new columns and modify existing ones.\n:::\n\n\n## Context\n\nIn the [tabular data](#tabular-data) section we learned to deal with, well, tabular data in the form of our `surveys` data set. This data set isn't huge, but sometimes we have many variables and we might only want to work with a subset of them. Or, we might want to create new columns based on existing data. In this section we'll cover how we can do this.\n\n## Section setup {#setup_plotting}\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe'll continue this section with the script named `da3-05-manipulating-columns.R`. If needed, add the following code to the top of your script and run it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A collection of R packages designed for data science\nlibrary(tidyverse)\n\nsurveys <- read_csv(\"data/surveys.csv\")\n```\n:::\n\n\n## Python\n\nWe'll continue this section with the script named `da3-05-manipulating-columns.py`. If needed, add the following code to the top of your script and run it.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# A Python data analysis and manipulation tool\nimport pandas as pd\n\n# Python equivalent of `ggplot2`\nfrom plotnine import *\n\nsurveys = pd.read_csv(\"data/surveys.csv\")\n```\n:::\n\n\n:::\n:::\n\n## Selecting columns\n\nLet's remind ourselves to which columns we have in our `surveys` data set. After that, we'll start making some changes.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(surveys)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"record_id\"       \"month\"           \"day\"             \"year\"           \n[5] \"plot_id\"         \"species_id\"      \"sex\"             \"hindfoot_length\"\n[9] \"weight\"         \n```\n\n\n:::\n:::\n\n \n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIndex(['record_id', 'month', 'day', 'year', 'plot_id', 'species_id', 'sex',\n       'hindfoot_length', 'weight'],\n      dtype='object')\n```\n\n\n:::\n:::\n\n\n:::\n\n### Selecting individual columns\n\nLet's say we wanted to select only the `record_id` and `year` columns. We've briefly done this when we looked at [subsetting rows and columns](#subset_rc).\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nHowever, there is an alternative way of doing this using the `dplyr` package - which is part of `tidyverse`.\n \n We can use the `select()` function:\n \n\n::: {.cell}\n\n```{.r .cell-code}\nselect(surveys, record_id, year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 2\n   record_id  year\n       <dbl> <dbl>\n 1         1  1977\n 2         2  1977\n 3         3  1977\n 4         4  1977\n 5         5  1977\n 6         6  1977\n 7         7  1977\n 8         8  1977\n 9         9  1977\n10        10  1977\n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n \nUsing the base R syntax, this is equivalent to `surveys[, c(\"record_id\", \"year\")]`. Notice that with the `select()` function (and generally with `dplyr` functions) we didn’t need to quote \" the column names. This is because the first input to the function is the table name, and so everything after is assumed to be column names of that table.\n\n## Python\n\nThe way we need to specify this is by giving a list of column names `[\"record_id\", \"year\"]` and subsetting the surveys data set with this.\n\nThe way we subset is with `surveys[ ]`, so we end up with double square brackets:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys[[\"record_id\", \"year\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  year\n0              1  1977\n1              2  1977\n2              3  1977\n3              4  1977\n4              5  1977\n...          ...   ...\n35544      35545  2002\n35545      35546  2002\n35546      35547  2002\n35547      35548  2002\n35548      35549  2002\n\n[35549 rows x 2 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\n### Selecting with helper functions\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nThe `select()` function becomes particularly useful when we combine it with other helper functions. For example, this code will select all the columns where the column name contains the string (text) `\"_id\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# returns all columns where the column name contains the text \"_id\"\nselect(surveys, contains(\"_id\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 3\n   record_id plot_id species_id\n       <dbl>   <dbl> <chr>     \n 1         1       2 NL        \n 2         2       3 NL        \n 3         3       2 DM        \n 4         4       7 DM        \n 5         5       3 DM        \n 6         6       1 PF        \n 7         7       2 PE        \n 8         8       1 DM        \n 9         9       1 DM        \n10        10       6 PF        \n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\nThe subsetting becomes a bit tedious when we're looking for patterns in the column names. Here, we can instead use the `.filter` attribute of the surveys data set, and look for a string (text) where the column name contains `\"_id\"`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.filter(like = \"_id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  plot_id species_id\n0              1        2         NL\n1              2        3         NL\n2              3        2         DM\n3              4        7         DM\n4              5        3         DM\n...          ...      ...        ...\n35544      35545       15         AH\n35545      35546       15         AH\n35546      35547       10         RM\n35547      35548        7         DO\n35548      35549        5        NaN\n\n[35549 rows x 3 columns]\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### Selecting a range of columns\n\nLet's say we're interested in all the columns from `record_id` to `year`.\n\n::: {.panel-tabset group=\"language\"}\n## R\nIn that case, we can use the `:` symbol.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# returns all columns between and including record_id and year\nselect(surveys, record_id:year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 4\n   record_id month   day  year\n       <dbl> <dbl> <dbl> <dbl>\n 1         1     7    16  1977\n 2         2     7    16  1977\n 3         3     7    16  1977\n 4         4     7    16  1977\n 5         5     7    16  1977\n 6         6     7    16  1977\n 7         7     7    16  1977\n 8         8     7    16  1977\n 9         9     7    16  1977\n10        10     7    16  1977\n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\nWe can also combine this with the previous method:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# returns all columns between and including record_id and year\n# and all columns where the column name contains the text \"_id\"\nselect(surveys, record_id:year, contains(\"_id\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 6\n   record_id month   day  year plot_id species_id\n       <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>     \n 1         1     7    16  1977       2 NL        \n 2         2     7    16  1977       3 NL        \n 3         3     7    16  1977       2 DM        \n 4         4     7    16  1977       7 DM        \n 5         5     7    16  1977       3 DM        \n 6         6     7    16  1977       1 PF        \n 7         7     7    16  1977       2 PE        \n 8         8     7    16  1977       1 DM        \n 9         9     7    16  1977       1 DM        \n10        10     7    16  1977       6 PF        \n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\nIn that case, we can use the `:` symbol, in combination with the `.loc` indexer.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.loc[:, \"record_id\":\"year\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  month  day  year\n0              1      7   16  1977\n1              2      7   16  1977\n2              3      7   16  1977\n3              4      7   16  1977\n4              5      7   16  1977\n...          ...    ...  ...   ...\n35544      35545     12   31  2002\n35545      35546     12   31  2002\n35546      35547     12   31  2002\n35547      35548     12   31  2002\n35548      35549     12   31  2002\n\n[35549 rows x 4 columns]\n```\n\n\n:::\n:::\n\n\n\n:::\n\n### Unselecting columns\n\nLastly, we can also **unselect columns**. This can be useful when you want most columns, apart from some.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nTo do this, we use the `-` symbol before the column name.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# returns all columns apart from record_id\nselect(surveys, -record_id)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 8\n   month   day  year plot_id species_id sex   hindfoot_length weight\n   <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>  <dbl>\n 1     7    16  1977       2 NL         M                  32     NA\n 2     7    16  1977       3 NL         M                  33     NA\n 3     7    16  1977       2 DM         F                  37     NA\n 4     7    16  1977       7 DM         M                  36     NA\n 5     7    16  1977       3 DM         M                  35     NA\n 6     7    16  1977       1 PF         M                  14     NA\n 7     7    16  1977       2 PE         F                  NA     NA\n 8     7    16  1977       1 DM         M                  37     NA\n 9     7    16  1977       1 DM         F                  34     NA\n10     7    16  1977       6 PF         F                  20     NA\n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\nTo do this, we use the `.drop` attribute. Here, we only unselect one column, but we can easily extend this by providing a list of columns do the `column =` argument.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.drop(columns = \"record_id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       month  day  year  plot_id species_id  sex  hindfoot_length  weight\n0          7   16  1977        2         NL    M             32.0     NaN\n1          7   16  1977        3         NL    M             33.0     NaN\n2          7   16  1977        2         DM    F             37.0     NaN\n3          7   16  1977        7         DM    M             36.0     NaN\n4          7   16  1977        3         DM    M             35.0     NaN\n...      ...  ...   ...      ...        ...  ...              ...     ...\n35544     12   31  2002       15         AH  NaN              NaN     NaN\n35545     12   31  2002       15         AH  NaN              NaN     NaN\n35546     12   31  2002       10         RM    F             15.0    14.0\n35547     12   31  2002        7         DO    M             36.0    51.0\n35548     12   31  2002        5        NaN  NaN              NaN     NaN\n\n[35549 rows x 8 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\n## Renaming and reshuffling columns\n\n### Renaming columns\n\nFor example, we might want to change the `weight` column name to `weight_g`, to reflect that the values are in grams.\n\n::: {.panel-tabset group=\"language\"}\n## R\nWe can use the `rename()` function to change a column name. We do this as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrename(surveys, weight_g = weight)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 9\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight_g\n       <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>    <dbl>\n 1         1     7    16  1977       2 NL         M                  32       NA\n 2         2     7    16  1977       3 NL         M                  33       NA\n 3         3     7    16  1977       2 DM         F                  37       NA\n 4         4     7    16  1977       7 DM         M                  36       NA\n 5         5     7    16  1977       3 DM         M                  35       NA\n 6         6     7    16  1977       1 PF         M                  14       NA\n 7         7     7    16  1977       2 PE         F                  NA       NA\n 8         8     7    16  1977       1 DM         M                  37       NA\n 9         9     7    16  1977       1 DM         F                  34       NA\n10        10     7    16  1977       6 PF         F                  20       NA\n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\nWe can use the `.rename()` attribute of the `surveys` Pandas data frame:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.rename(columns = {'weight': 'weight_g'})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  month  day  year  ...  species_id  sex hindfoot_length  weight_g\n0              1      7   16  1977  ...          NL    M            32.0       NaN\n1              2      7   16  1977  ...          NL    M            33.0       NaN\n2              3      7   16  1977  ...          DM    F            37.0       NaN\n3              4      7   16  1977  ...          DM    M            36.0       NaN\n4              5      7   16  1977  ...          DM    M            35.0       NaN\n...          ...    ...  ...   ...  ...         ...  ...             ...       ...\n35544      35545     12   31  2002  ...          AH  NaN             NaN       NaN\n35545      35546     12   31  2002  ...          AH  NaN             NaN       NaN\n35546      35547     12   31  2002  ...          RM    F            15.0      14.0\n35547      35548     12   31  2002  ...          DO    M            36.0      51.0\n35548      35549     12   31  2002  ...         NaN  NaN             NaN       NaN\n\n[35549 rows x 9 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\n### Reshuffling columns\n\nIt might be that you want to reorder/reshuffle a column. Here, the `year` column is our fourth variable. Let's say we'd want to  move this to the second position (after `record_id`).\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can use the `relocate()` function to do this. The function has several arguments, starting with `.`, such as `.before =` or `.after =`. These allow you to specify where you want to reinsert the column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrelocate(surveys, year, .after = record_id)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 9\n   record_id  year month   day plot_id species_id sex   hindfoot_length weight\n       <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>  <dbl>\n 1         1  1977     7    16       2 NL         M                  32     NA\n 2         2  1977     7    16       3 NL         M                  33     NA\n 3         3  1977     7    16       2 DM         F                  37     NA\n 4         4  1977     7    16       7 DM         M                  36     NA\n 5         5  1977     7    16       3 DM         M                  35     NA\n 6         6  1977     7    16       1 PF         M                  14     NA\n 7         7  1977     7    16       2 PE         F                  NA     NA\n 8         8  1977     7    16       1 DM         M                  37     NA\n 9         9  1977     7    16       1 DM         F                  34     NA\n10        10  1977     7    16       6 PF         F                  20     NA\n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\n\n## Python\n\nUnlike in R, there isn't a very clear, straightforward way of reinserting columns in a Pandas data frame. We could show you convoluted ways of doing so, but at this point that's just confusing. So, we'll leave you with a [link to a Stackoverflow solution](https://stackoverflow.com/questions/13148429/how-to-change-the-order-of-dataframe-columns).\n:::\n\n## Creating new columns\n\nSometimes we need to create new columns. For example, we might have a variable that is not in the unit of measurement we need (e.g. in millimeters, instead of centimeters).\n\nConceptually, that looks something like this:\n\n![Creating a new column using data from an existing one.](images/manipulation-new_column.png){#fig-manipulation_new}\n\nLet's illustrate this with an example on our `surveys` data set. Let's say we wanted to get `hindfoot_length` in centimeters, instead of millimeters. We'd have to go through each row, take the `hindfoot_length` value and divide it by 10. We then need to store this output in a column called, for example, `hindfoot_length_cm`.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can use the `mutate()` function to create new columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(surveys, hindfoot_length_cm = hindfoot_length / 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 10\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>  <dbl>\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2         2     7    16  1977       3 NL         M                  33     NA\n 3         3     7    16  1977       2 DM         F                  37     NA\n 4         4     7    16  1977       7 DM         M                  36     NA\n 5         5     7    16  1977       3 DM         M                  35     NA\n 6         6     7    16  1977       1 PF         M                  14     NA\n 7         7     7    16  1977       2 PE         F                  NA     NA\n 8         8     7    16  1977       1 DM         M                  37     NA\n 9         9     7    16  1977       1 DM         F                  34     NA\n10        10     7    16  1977       6 PF         F                  20     NA\n# ℹ 35,539 more rows\n# ℹ 1 more variable: hindfoot_length_cm <dbl>\n```\n\n\n:::\n:::\n\n\n## Python\n\nWe use the square brackets to define the name of the new column, then specify what needs to go in the new column:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys['hindfoot_length_cm'] = surveys['hindfoot_length'] / 10\n```\n:::\n\n\n:::\n\nAlthough it has created the column, we can't quite see it because we have too many columns. So, let's save the new column to the data set and then select the relevant columns.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nFirst, we update our data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys <- mutate(surveys, hindfoot_length_cm = hindfoot_length / 10)\n```\n:::\n\n\nNext, we can select the columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(surveys, record_id, hindfoot_length, hindfoot_length_cm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 3\n   record_id hindfoot_length hindfoot_length_cm\n       <dbl>           <dbl>              <dbl>\n 1         1              32                3.2\n 2         2              33                3.3\n 3         3              37                3.7\n 4         4              36                3.6\n 5         5              35                3.5\n 6         6              14                1.4\n 7         7              NA               NA  \n 8         8              37                3.7\n 9         9              34                3.4\n10        10              20                2  \n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\n## Python\n\nOur previous step already added the new column to the DataFrame, so we can directly select the relevant columns, by giving a list of the columns we're interested in:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys[['record_id', 'hindfoot_length', 'hindfoot_length_cm']]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  hindfoot_length  hindfoot_length_cm\n0              1             32.0                 3.2\n1              2             33.0                 3.3\n2              3             37.0                 3.7\n3              4             36.0                 3.6\n4              5             35.0                 3.5\n...          ...              ...                 ...\n35544      35545              NaN                 NaN\n35545      35546              NaN                 NaN\n35546      35547             15.0                 1.5\n35547      35548             36.0                 3.6\n35548      35549              NaN                 NaN\n\n[35549 rows x 3 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\nWe can see that each value in `hindfoot_length_cm` is a tenth of the value of `hindfoot_length`. This is exactly what we expected!\n\n## Summary\n\n::: {.callout-tip}\n#### Key points\n\n- We have several functions available that allow us to select, move, rename and create new columns\n:::\n",
    "supporting": [
      "da3-05-manipulating-columns_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}