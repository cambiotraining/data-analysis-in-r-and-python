{
  "hash": "8ac82e883faf700525d3f3047df8491a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Data types & structures\n---\n\n::: {.callout-tip}\n#### Learning objectives\n\n- Create familiarity with the most common data types.\n- Know about basic data structures.\n- Create, use and make changes to objects.\n- Create, use and make changes to collections of data.\n- Deal with missing data.\n:::\n\n\n## Context\n\nWe’ve seen examples where we entered data directly into a function. Most of the time we have data from elsewhere, such as a spreadsheet. In the previous section we created single objects. We’ll build up from this and introduce vectors and tabular data. We'll also briefly mention other data types, such as matrices, arrays.\n\n## Explained: Data types & structures\n\nComputers are picky when it comes to data and they like consistency. As such, it's good to be aware of the fact that data can be viewed or interpreted in different ways by the computer.\n\nFor example, you might have research data where the presence or absence of a tumour is scored. This would often be recorded as `0` when absent and `1` as present. Your computer views these values as numbers and would happily calculate the average of those values. Not ideal, because a tumour being, on average, `0.3` present makes no sense!\n\nSo, it is important to spend a bit of time looking at your data to make sure that the computer sees it in the correct way.\n\n### Quantitative data\n\n#### Discrete data\n\nDiscrete data are numerical data that can only take distinct values. They can be counted and only take whole numbers. Examples of discrete data include, for example, the number of planets in a solar system or the number of questions answered on an exam.\n\n|                                 | Description                                      |\n|------------|--------------------------------------------------|\n| <i class=\"fa fa-list-check fa-1x\"></i> | The number of questions answered on an exam (e.g. 12 out of 20) |\n| <i class=\"fa fa-check-circle fa-1x\"></i> | If somebody has completed a survey (binary data; yes/no) |\n| <i class=\"fa fa-users fa-1x\"></i>    | The number of students in a class (e.g. 20, 32) |\n\n\n\n#### Continuous data\n\nContinuous data can take any value within a given range. These data can be measured and can include decimals or fractions.\n\n|                                 | Description                                      |\n|------------|--------------------------------------------------|\n| <i class=\"fa fa-thermometer-half fa-1x\"></i> | Temperature of a liquid (e.g. 20 &deg;C) |\n| <i class=\"fa fa-ruler fa-1x\"></i>    | Height of people in a cohort (e.g. 168 cm) |\n| <i class=\"fa fa-heartbeat fa-1x\"></i> | Average heart rate in a patient (e.g. 70 beats per minute) |\n| <i class=\"fa fa-tint fa-1x\"></i>     | Water levels in an aquifer (e.g. 2.4 metres) |\n\n### Qualitative data\n\nQualitative data are data that describe qualities which can't be measured or quantified numerically. We can roughly split these data into two types: ones with an inherent order to them, and ones without.\n\n#### Nominal data: categories\n\nThese are categorical data that represent categories or distinct groups, without any inherent order or ranking.\n\n|                                 | Description                                      |\n|------------|--------------------------------------------------|\n| <i class=\"fa fa-eye fa-1x\"></i>      | Eye colour (e.g. blue, brown) |\n| <i class=\"fa fa-university fa-1x\"></i> | Education level (e.g. primary school, secondary school) |\n| <i class=\"fa fa-flask fa-1x\"></i>    | Treatment group (e.g. control, treatment) |\n\n\n\n#### Ordinal data: categories with ranking or ordering\nOrdinal data are similar to nominal data, in that they represent different categories or groups. However, these also have an inherent ordering to them.\n\n|                                 | Description                                      |\n|------------|--------------------------------------------------|\n| <i class=\"fa fa-star fa-1x\"></i>     | Rating scale (e.g., 1 to 5 stars for difficulty levels) |\n| <i class=\"fa fa-trophy fa-1x\"></i>   | Rank or position (e.g., 1st, 2nd, 3rd place in a tournament) |\n| <i class=\"fa fa-sort-amount-up fa-1x\"></i> | Order or progression (e.g., low, medium, high priority) |\n\n\n\n### Getting the computer to see the right way\n\nIn general, computers can view these different types of data in specific ways.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nR has the following main data types:\n\n| Data&nbsp;type | Description|\n|-----------|--------------------------------------------------------------|\n| numeric   | Represents numbers; can be whole (integers) or decimals \\\n(e.g., `19`or `2.73`).|\n| integer   | Specific type of numeric data; can only be an integer \\\n(e.g., `7L` where `L` indicates an integer). |\n| character | Also called *text* or *string* \\\n(e.g., `\"Rabbits are great!\"`).|\n| logical   | Also called *boolean values*; takes either `TRUE` or `FALSE`.|\n| factor    | A type of categorical data that can have inherent ordering \\\n(e.g., `low`, `medium`, `high`).|\n\n\n## Python\n\nPython has the following main data types:\n\n| Data type | Description|\n|-----------|--------------------------------------------------------------|\n| int       | Specific type of numeric data; can only be an integer \\\n(e.g., `7` or `56`).|\n| float     | Decimal numbers \\\n(e.g., `3.92` or `9.824`).|\n| str       | *Text* or *string* data \\\n(e.g., `\"Rabbits are great!\"`).|\n| bool      | *Logical* or *boolean* values; takes either `True` or `False`.|\n\n:::\n\n### Data structures\n\nIn the section on [running code](#running-code) we saw how we can run code interactively. However, we frequently need to save values so we can work with them. We've just seen that we can have different *types* of data. We can save these into different *data structures*. Which data structure you need is often determined by the type of data and the complexity.\n\nIn the following sections we look at simple data structures.\n\n## Objects\n\nWe can store values into *objects*. To do this, we *assign* values to them. An object acts as a container for that value.\n\nTo create an object, we need to give it a name followed by the\nassignment operator and the value we want to give it, for example:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemperature <- 23\n```\n:::\n\n\nWe can read the code as: the value `23` is assigned (`<-`) to the object `temperature`. Note that when you run this line of code the object you just created appears on your environment tab (top-right panel).\n\nWhen assigning a value to an object, R does not print anything on the console. You can print the value by typing the object name on the console or within your script and running that line of code.\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemperature = 23\n```\n:::\n\n\nWe can read the code as: the value `23` is assigned (`=`) to the object `temperature`.\n\nWhen assigning a value to an object, Python does not print anything on the console. You can print the value by typing the object name on the console or within your script and running that line of code.\n\n:::\n\n::: {.callout-important}\n## The assignment operator\n\nWe use an assignment operator to assign values on the right to objects on the left.\n\n::: {.panel-tabset group=\"language\"}\n## R\nIn R we use `<-` as the assignment operator.\n\nIn RStudio, typing <kbd>Alt</kbd> + <kbd>-</kbd> (push <kbd>Alt</kbd> at the same time as the <kbd>-</kbd> key) will write ` <- ` in a single keystroke on a PC, while typing <kbd>Option</kbd> + <kbd>-</kbd> (push <kbd>Option</kbd> at the same time as the <kbd>-</kbd> key) does the same on a Mac. <br /><br />\n\n::: {.callout-note}\nAlthough R also supports the use of `=` as an assignment operator, there are some very slight differences in their use, as [illustrated here](https://stackoverflow.com/questions/1741820/what-are-the-differences-between-and-assignment-operators). Generally, people just stick to `<-` for those reasons.\n:::\n\n## Python\nIn Python we use `=` as the assignment operator. <br /><br />\n\n:::\n:::\n\nObjects can be given almost any name such as `x`, `current_temperature`, or\n`subject_id`. You want the object names to be explicit and short. There are some exceptions / considerations (see below).\n\n::: {.callout-warning}\n## Restrictions on object names\n\nObject names can contain letters, numbers, underscores and periods.\n\nThey *cannot start with a number nor contain spaces*.\nDifferent people use different conventions for long variable names, two common ones being:\n\nUnderscore: `my_long_named_object`\n\nCamel case: `myLongNamedObject`\n\nWhat you use is up to you, but be consistent. Programming languages are **case-sensitive** so `temperature` is different from `Temperature.`\n\n* Some names are reserved words or keywords, because they are the names of core functions (e.g., `if`, `else`, `for`, see [R](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html) or [Python](https://docs.python.org/3/reference/lexical_analysis.html#keywords) for a complete list).\n* Avoid using function names (e.g., `c`, `T`, `mean`, `data`, `df`, `weights`), even if allowed. If in doubt, check the help to see if the name is already in use.\n* Avoid full-stops (`.`) within an object name as in `my.data`. Full-stops often have meaning in programming languages, so it's best to avoid them.\n* Use consistent styling.\n\n**Whatever style you use, be consistent!**\n:::\n\n### Using objects\n\nNow that we have the `temperature` in memory, we can use it to perform operations. For example, this might the temperature in Celsius and we might want to calculate it to Kelvin.\n\nTo do this, we need to add `273.15`:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemperature + 273.15\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 296.15\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemperature + 273.15\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n296.15\n```\n\n\n:::\n:::\n\n:::\n\nWe can change an object's value by assigning a new one:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemperature <- 36\ntemperature + 273.15\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 309.15\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemperature = 36\ntemperature + 273.15\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n309.15\n```\n\n\n:::\n:::\n\n:::\n\nFinally, assigning a value to one object does not change the values of other objects. For example, let’s store the outcome in Kelvin into a new object `temp_K`:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp_K <- temperature + 273.15\n```\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemp_K = temperature + 273.15\n```\n:::\n\n:::\n\nChanging the value of `temperature` does not change the value of `temp_K`.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemperature <- 14\ntemp_K\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 309.15\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemperature = 14\ntemp_K\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n309.15\n```\n\n\n:::\n:::\n\n:::\n\n## Collections of data\n\nIn the examples above we have stored single values into an object. Of course we often have to deal with more than that. Generally speaking, we can create **collections** of data. This enables us to organise our data, for example by creating a collection of numbers or text values.\n\nCreating a collection of data is pretty straightforward, particularly if you are doing it manually. Conceptually, we can of these collections in 4 distinct ways, based on the type of data they contain. We'll cover tabular data in the next chapter.\n\n| Collection        | R                   | Python               |\n| ----------------- | ------------------- | -------------------- |\n| 1D homogeneous    | vector              | NumPy array (1D)     |\n| 2D homogeneous    | matrix / array      | NumPy array (2D)     |\n| General container | list                | list / tuple         |\n| Tabular (mixed)   | data.frame/tibble   | pandas DataFrame     |\n\n\n::: {.callout-important}\n## Having a type\n\nDifferent data types result in slightly different types of objects. It can be quite useful to check how your data is viewed by the computer.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can use the `class()` function to check what type of object we're dealing with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(temp_K)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n## Python\n\nWe can use the `type()` function to check what type of object we're dealing with.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntype(temp_K)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'float'>\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n### Homogeneous (1D)\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nThe simplest collection of data in R is called a **vector**. This really is the workhorse of R.\n\nA vector is composed by a series of values, which can numbers, text or any of the data types described. However, they are expected to all be of the same type.\n\nWe can assign a series of values to a vector using the `c()` function. For example, we can create a vector of temperatures and assign it to a new object `temp_c`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp_c <- c(23, 24, 31, 27, 18, 21)\n\ntemp_c        # check object contents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 23 24 31 27 18 21\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(temp_c) # check object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\nA vector can also contain text. For example, let's create a vector that contains weather descriptions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather <- c(\"sunny\", \"cloudy\", \"partial_cloud\", \"cloudy\", \"sunny\", \"rainy\")\n\nweather        # check object contents \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"sunny\"         \"cloudy\"        \"partial_cloud\" \"cloudy\"       \n[5] \"sunny\"         \"rainy\"        \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(weather) # check object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n## Python\n\nIn Python NumPy arrays are incredibly efficient for computing, so they are widely used. We can access NumPy as follows:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n```\n:::\n\n\nNext, we can create a simple NumPy array that contains numbers.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemp_c = np.array([23, 24, 31, 27, 18, 21])\n\ntemp_c       # check object contents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([23, 24, 31, 27, 18, 21])\n```\n\n\n:::\n\n```{.python .cell-code}\ntype(temp_c) # check object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'numpy.ndarray'>\n```\n\n\n:::\n:::\n\n\nWe can do something similar using text / character strings:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nweather = ([\"sunny\", \"cloudy\", \"partial_cloud\", \"cloudy\", \"sunny\", \"rainy\"])\n\nweather       # check object contents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['sunny', 'cloudy', 'partial_cloud', 'cloudy', 'sunny', 'rainy']\n```\n\n\n:::\n\n```{.python .cell-code}\ntype(weather) # check object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'list'>\n```\n\n\n:::\n:::\n\n\n:::\n\nNote that when we define text (e.g. `\"cloudy\"` or `\"sunny\"`), we need to use quotes.\n\nWhen we deal with numbers - whole or decimal (e.g. `23`, `18.5`) - we do not use quotes.\n\n### Homogeneous (2D)\n\nOften we have more than just one set of data points. Following our `temperature` example, let's say we measured minimum and maximum temperatures across a range of days.\n\nWe could arrange them in two columns, one with the minimum and one with the maximum values. All of the data is of the same type: numerical.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nIn R we can do this by creating an array / matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemps <- array(c(18, 20, 25, 22, 15, 17,\n                 23, 24, 31, 27, 18, 21),\n               dim = c(6, 2))\n\ntemps        # check object contents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2]\n[1,]   18   23\n[2,]   20   24\n[3,]   25   31\n[4,]   22   27\n[5,]   15   18\n[6,]   17   21\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(temps) # check object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n:::\n\n\n\n## Python\n\nIn Python we can do this by creating a NumPy array:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemps = np.array([\n    [18, 23],\n    [20, 24],\n    [25, 31],\n    [22, 27],\n    [15, 18],\n    [17, 21]\n])\n\ntemps       # check object contents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([[18, 23],\n       [20, 24],\n       [25, 31],\n       [22, 27],\n       [15, 18],\n       [17, 21]])\n```\n\n\n:::\n\n```{.python .cell-code}\ntemps.shape # check object dimensions\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(6, 2)\n```\n\n\n:::\n\n```{.python .cell-code}\ntype(temps) # check object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'numpy.ndarray'>\n```\n\n\n:::\n:::\n\n\n:::\n\n### General container\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nIn R we can use a **list** to store different types of data - which do not need to be of the same length (this is different to tabular data, which we'll cover in the next chapter).\n\nHave a look at the following example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_example <- list(\n  temperature = c(18, 20, 25, 22, 15, 17),     # numeric vector\n  weather     = c(\"sunny\", \"cloudy\", \"rainy\"), # character vector\n  flag        = TRUE,                          # logical\n  note        = \"Weather observations\"         # string\n)\n\nlist_example        # check object contents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$temperature\n[1] 18 20 25 22 15 17\n\n$weather\n[1] \"sunny\"  \"cloudy\" \"rainy\" \n\n$flag\n[1] TRUE\n\n$note\n[1] \"Weather observations\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(list_example) # check object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n\nThis returns all the individual parts of the list. We won't work much with lists in this course, but you're likely to encounter them in the future - for example if you're doing statistical analysis.\n\n## Python\n\nGeneral data containers in Python can either a **list** or a **tuple**. Both can hold items of the same of different types. The difference between the two is that a list can be changed (mutable), whereas a tuple *cannot* be changed after it's created (immutable).\n\nWe can assign a collection of numbers to a list:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemp_c = [23, 24, 31, 27, 18, 21]\n\ntemp_c       # check object contents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[23, 24, 31, 27, 18, 21]\n```\n\n\n:::\n\n```{.python .cell-code}\ntype(temp_c) # check object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'list'>\n```\n\n\n:::\n:::\n\n\nA list can also contain text. For example, let's create a list that contains weather descriptions:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nweather = [\"sunny\", \"cloudy\", \"partial_cloud\", \"cloudy\", \"sunny\", \"rainy\"]\n\nweather       # check object contents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['sunny', 'cloudy', 'partial_cloud', 'cloudy', 'sunny', 'rainy']\n```\n\n\n:::\n\n```{.python .cell-code}\ntype(weather) # check object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'list'>\n```\n\n\n:::\n:::\n\n\nWe can also create a *tuple*. Remember, this is like a list, but it cannot be altered after creating it. Note the difference in the type of brackets, where we use `( )` round brackets instead of `[ ]` square brackets:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemp_c_tuple = (23, 24, 31, 27, 18, 21)\n\ntemp_c_tuple       # check object contents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(23, 24, 31, 27, 18, 21)\n```\n\n\n:::\n\n```{.python .cell-code}\ntype(temp_c_tuple) # check object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'tuple'>\n```\n\n\n:::\n:::\n\n\n:::\n\n## Type coercion\n\nThis occurs when there are more than one type of data (e.g. numerical, text, logical) in an object that expects all data to be the same. What the computer then does is to *coerce* all the data to a common type that avoids data loss. \n\nTake a look at the following example, where we're mixing different data types.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_data <- c(264, NA, \"Bob\", 12)\n\nmixed_data        # object contents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"264\" NA    \"Bob\" \"12\" \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(mixed_data) # object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\nWhat has happened is that all values have been coerced to character.\n\n## Python\n\nIn Python, lists are fine with different types of data. NumPy arrays however expect a single type.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmixed_data = np.array([264, None, \"Bob\", 12])\n\nmixed_data       # object contents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([264, None, 'Bob', 12], dtype=object)\n```\n\n\n:::\n\n```{.python .cell-code}\ntype(mixed_data) # object type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'numpy.ndarray'>\n```\n\n\n:::\n:::\n\n\nWe can see that the object type is a NumPy array, but at the output of the data we see `dtype=object`, which means character data.\n:::\n\nThis happens because the computer doesn't know what to do when it encounters more than one data type (numerical, logical and text, in this case). To preserve as much data, it converts everything to text.\n\n### Converting types\n\nIn some cases you might want to enforce a certain data type. If you do this, just be aware that some data *could* get lost.\n\nLook at the following example, where we create a very simple 1D collection of data, where we introduced a number in quotes, so it's viewed as text. In this case, forcing all the data as numeric would fix that error.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp_error <- c(12, 23, \"18\", 26)\n\nclass(temp_error)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp_error <- as.numeric(temp_error)\n\nclass(temp_error)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n\n## Python\n\nHere we create a NumPy array and check the data type:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemp_error = np.array([12, 23, \"18\", 26])\n\nprint(temp_error, temp_error.dtype) # check the contents and data type\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['12' '23' '18' '26'] <U21\n```\n\n\n:::\n:::\n\n\nIt gives us `<U21` as a data type. This indicates that NumPy sized the array as a Unicode string array with a maximum of 21 characters. That's quite a long-winded way of saying \"they are not viewed as numbers\".\n\nThankfully we can fix that, by converting the type to `int` or integers.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemp_error = temp_error.astype(int)\n\nprint(temp_error, temp_error.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[12 23 18 26] int64\n```\n\n\n:::\n:::\n\n\n:::\n\n## Making changes\n\nQuite often we would want to make some changes to a collection of data. There are different ways we can do this.\n\nLet's say we gathered some new temperature data and wanted to add this to the original `temp_c` data.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe'd use the `c()` function to combine the new data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(temp_c, 22, 34)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 23 24 31 27 18 21 22 34\n```\n\n\n:::\n:::\n\n\n\n## Python\n\nWe take the original `temp_c` list and add the new values:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemp_c + [22, 34]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[23, 24, 31, 27, 18, 21, 22, 34]\n```\n\n\n:::\n:::\n\n\n:::\n\nLet's consider another scenario. Again, we went out to gather some new temperature data, but this time we stored the measurements into an object called `temp_new` and wanted to add these to the original `temp_c` data.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp_new <- c(5, 16, 8, 12)\n```\n:::\n\n\nNext, we wanted to combine these new data with the original data, which we stored in `temp_c`.\n\nAgain, we can use the `c()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(temp_c, temp_new)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 23 24 31 27 18 21  5 16  8 12\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemp_new = [5, 16, 8, 12]\n```\n:::\n\n\nWe can use the `+` operator to add the two lists together:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ntemp_c + temp_new\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[23, 24, 31, 27, 18, 21, 5, 16, 8, 12]\n```\n\n\n:::\n:::\n\n\n:::\n\n### Number sequences\n\nWe often need to create sequences of numbers when analysing data. There are some useful shortcuts available to do this, which can be used in different situations. Run the following code to see the output.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10                                # integers from 1 to 10\n10:1                                # integers from 10 to 1\nseq(1, 10, by = 2)                  # from 1 to 10 by steps of 2\nseq(10, 1, by = -0.5)               # from 10 to 1 by steps of -0.5\nseq(1, 10, length.out = 21)         # 21 equally spaced values from 1 to 10\n```\n:::\n\n\n\n## Python\n\nPython has some built-in functionality to deal with number sequences, but the `numpy` library is particularly helpful. We installed and loaded it previously, but if needed, re-run the following:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n```\n:::\n\n\nNext, we can create several different number sequences:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlist(range(1, 11))                 # integers from 1 to 10\nlist(range(10, 0, -1))             # integers from 10 to 1\nlist(range(1, 11, 2))              # from 1 to 10 by steps of 2\nlist(np.arange(10, 1, -0.5))       # from 10 to 1 by steps of -0.5\nlist(np.linspace(1, 10, num = 21)) # 21 equally spaced values from 1 to 10\n```\n:::\n\n\n\n:::\n\n## Subsetting\n\nSometimes we want to extract one or more values from a collection of data. We will go into more detail later, but for now we'll see how to do this on the simple data structures we've covered so far.\n\n::: {.callout-warning collapse=\"true\"}\n## Technical: Differences in indexing between R and Python\n\nIn the course materials we keep R and Python separate in most cases. However, if you end up using both languages at some point then it's important to be aware about some key differences. One of them is **indexing**.\n\nEach item in a collection of data has a number, called an *index*. Now, it would be great if this was consistent across all programming languages, but it's not.\n\nR uses **1-based indexing** whereas Python uses **zero-based indexing**. What does this mean? Compare the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplants <- c(\"tree\", \"shrub\", \"grass\") # the index of \"tree\" is 1, \"shrub\" is 2 etc.\n```\n:::\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nplants = [\"tree\", \"shrub\", \"grass\"]   # the index of \"tree\" is 0, \"shrub\" is 1 etc.  \n```\n:::\n\n\n\nBehind the scenes of any programming language there is a lot of counting going on. So, it matters if you count starting at zero or one. So, if I'd ask:\n\n\"Hey, R - give me the items with index 1 and 2 in `plants`\" then I'd get `tree` and `shrub`. \n\nIf I'd ask that question in Python, then I'd get `shrub` and `grass`. Fun times.\n:::\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nIn R we can use square brackets `[ ]` to extract values. Let's explore this using our `weather` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nweather          # remind ourselves of the data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"sunny\"         \"cloudy\"        \"partial_cloud\" \"cloudy\"       \n[5] \"sunny\"         \"rainy\"        \n```\n\n\n:::\n\n```{.r .cell-code}\nweather[2]       # extract the second value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"cloudy\"\n```\n\n\n:::\n\n```{.r .cell-code}\nweather[2:4]     # extract the second to fourth value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"cloudy\"        \"partial_cloud\" \"cloudy\"       \n```\n\n\n:::\n\n```{.r .cell-code}\nweather[c(3, 1)] # extract the third and first value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"partial_cloud\" \"sunny\"        \n```\n\n\n:::\n\n```{.r .cell-code}\nweather[-1]      # extract all apart from the first value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"cloudy\"        \"partial_cloud\" \"cloudy\"        \"sunny\"        \n[5] \"rainy\"        \n```\n\n\n:::\n:::\n\n\n## Python\n\nLet's explore this using our `weather` object.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nweather          # remind ourselves of the data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['sunny', 'cloudy', 'partial_cloud', 'cloudy', 'sunny', 'rainy']\n```\n\n\n:::\n\n```{.python .cell-code}\nweather[1]       # extract the second value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'cloudy'\n```\n\n\n:::\n\n```{.python .cell-code}\nweather[1:4]     # extract the second to fourth value (end index is exclusive)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['cloudy', 'partial_cloud', 'cloudy']\n```\n\n\n:::\n\n```{.python .cell-code}\nweather[2], weather[0] # extract the third and first value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n('partial_cloud', 'sunny')\n```\n\n\n:::\n\n```{.python .cell-code}\nweather[1:]      # extract all apart from the first value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['cloudy', 'partial_cloud', 'cloudy', 'sunny', 'rainy']\n```\n\n\n:::\n:::\n\n\n:::\n\n\n## Dealing with missing data {#missing-data}\n\nIt may seem weird that you have to consider what isn't there, but that's exactly what we do when we have missing data. Ideally, when we're collecting data we entries for every single thing we measure. But, alas, life is messy. That one patient may have missed an appointment, or one eppendorf tube got dropped, or etc etc.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nR includes the concept of missing data, meaning we can specify that a data point is missing. Missing data are represented as `NA`.\n\nWhen doing operations on numbers, most functions will return `NA` if the data you are working with include missing values. This makes it harder to overlook the cases where you are dealing with missing data. This is a good thing!\n\nFor example, let's look at the following data, where we have measured six different patients and recorded their systolic blood pressure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsystolic_pressure <- c(125, 134, NA, 145, NA, 141)\n```\n:::\n\n\nWe can see that we're missing measurements for two of them. If we want to calculate the average systolic blood pressure across these patients, then we could use the `mean()` function. However, this results in `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(systolic_pressure)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n:::\n\n\nThe reason that happens is because missing values are obviously not numbers and, as such, the `mean()` function doesn't know what to do with the. \n\nTo overcome this, we need to tell it to ignore missing values and *then* calculate the mean. We do this by adding the argument `na.rm = TRUE` to it. This argument works on many different functions and instructs it to remove missing values before any calculation takes place.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(systolic_pressure, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 136.25\n```\n\n\n:::\n:::\n\n\nThere are quite a few ways that you can deal with missing data and we'll discuss more of them in later sessions.\n\nWe can also count the number of missing values we have, by using the `is.na()` function, together with `sum()`. Look at the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(systolic_pressure)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE  TRUE FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\nFor each value in `systolic_pressure` we get a `TRUE` or `FALSE` value. If the value is `NA`, it returns `TRUE`. If not missing, `FALSE`. Behind the scenes R sees `TRUE` as a value of `1` and `FALSE` as a value of `0`. We can thus count the number of `TRUE` values with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(is.na(systolic_pressure))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\n## Python\n\nThe built-in functionality of Python is not very good at dealing with missing data. This means that you normally need to deal with them manually.\n\nOne of the ways you can denote missing data in Python is with `None`. Let's look at the following data, where we have measured six different patients and recorded their systolic blood pressure.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsystolic_pressure = [125, 134, None, 145, None, 141]\n```\n:::\n\n\nNext, we'd have to filter out the missing values (don't worry about the exact meaning of the code at this point):\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfiltered_data = [x for x in systolic_pressure if x is not None]\n```\n:::\n\n\nAnd lastly we would be able to calculate the mean value:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsum(filtered_data) / len(filtered_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n136.25\n```\n\n\n:::\n:::\n\n\nThere are quite a few (easier!) ways that you can deal with missing data and we'll discuss more of them in later sessions, once we start dealing with tabular data.\n:::\n\n::: {.callout-note}\n## To exclude or not exclude?\n\nIt may be tempting to simply remove all observations that contain missing data. It often makes the analysis easier! However, there is good reason to be more subtle: throwing away good data.\n\nLet's look at the following hypothetical data set, where we use `NA` to denote missing values. We are interested in the average weight and age across the patients.\n\n```\npatient_id    weight_kg   age\nN982          72          47\nN821          68          49\nN082          NA          63\nN651          78          NA\n```\n\nWe could remove all the rows that contain *any* missing data, thereby getting rid of the last two observations. However, that would mean we'd lose data on `age` from the penultimate row, and data on `weight_kg` from the last row.\n\nInstead, it would be better to tell the computer to ignore missing values on a variable-by-variable basis and calculate the averages on the data that *is* there.\n:::\n\n## Exercises\n\n### Creating objects {#sec-creating_objects}\n\n::::: {.callout-exercise #ex-creating_objects}\n#### Creating objects\n\n{{< level 1 >}}\n\nCreate an object that contains a sequence of even numbers between 1 and 21.\n\nUsing code, how many numbers are in the sequence?\n\n:::: {.callout-answer collapse=\"true\"}\n\nWe can do this as follows:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_seq <- seq(2, 21, by = 2)\n```\n:::\n\n\nDetermine the length:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(num_seq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnum_seq = list(range(2, 21, 2))\n```\n:::\n\n\nDetermine the length:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nlen(num_seq)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n10\n```\n\n\n:::\n:::\n\n\n:::\n\nThere are 10 numbers in the sequence.\n::::\n:::::\n\n### Subsetting {#sec-exr_subsetting}\n\n::::: {.callout-exercise #ex-subsetting}\n#### Subsetting\n\n{{< level 1 >}}\n\nFor this exercise you need to use the number sequence you created in @sec-creating_objects.\n\nUsing subsetting, select the second half of the sequence.\n\n:::: {.callout-answer collapse=\"true\"}\n\nWe determined that we have 10 numbers in the sequence, so we need to select the last 5.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_seq[6:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 14 16 18 20\n```\n\n\n:::\n:::\n\n\n\n## Python\n\nWe need to select items 5 to 10, which corresponds to start index `5` (inclusive) and stop index `10` (exclusive):\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnum_seq[5:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[12, 14, 16, 18, 20]\n```\n\n\n:::\n:::\n\n\nOr using negative slicing:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnum_seq[-5:]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[12, 14, 16, 18, 20]\n```\n\n\n:::\n:::\n\n\n:::\n::::\n:::::\n\n## Summary\n\n::: {.callout-tip}\n#### Key points\n\n- The most common data types include numerical, text and logical data.\n- We can store data in single objects, enabling us to use the data\n- Multiple data points and types can be stored as different collections of data\n- We can make changes to objects and collections of data\n- We need to be explicit about missing data\n:::\n",
    "supporting": [
      "da1-02-basic-objects-and-data-types_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}