{
  "hash": "cf7bce81894c77f18ad4c9970c026033",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Working with tabular data\n---\n\n::: {.callout-tip}\n#### Learning objectives\n\n- Understand the structure of tabular data.\n- Be able to read in tabular data.\n- Investigate properties of the data (e.g. types of variables, missing data).\n- Perform basic quality control checks.\n:::\n\n\n## Context\nIn the previous section we dealt with single objects and vectors/lists. Here we expand towards tabular data, which can be seen as a set of these grouped together.\n\n## Tabular data {#tabular-data}\nTables are organised in columns (vertical) and rows (horizontal). An example of a tabular data set is given in @fig-tabular_data.\n\nThere, each **column** contains a variable (a thing that we've measured). Each **row** is a unique observation. \n\n![An example of tabular data](images/tabular_data.png){#fig-tabular_data}\n\n## Working with data\nTabular data sets are often created in spreadsheet programmes, such as Excel. These programmes are actually very well-suited, since they make it easy to enter data and keep an overview. When it comes to *analysing* these data, we're better off using coding - that way we can keep track of our analysis.\n\nThe default Excel format is not great, since it's a propriety format and not natively readable by other computer programmes. Good alternatives are `.csv` (comma-separated values) files or `.tsv` (tab-separated values) files.\n\nFor the next few sections we'll be using the `surveys.csv` data set (which you should now have in your `data-analysis/data` sub folder).\n\nWe'll read in these data now.\n\n::: {.panel-tabset group=\"language\"}\n## R\nIf you haven't done so already, make sure to load the `tidyverse` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nNext, we read in the file using the `read_csv()` function. Note that there is also a `read.csv()` function, but that one behaves slightly differently, so ensure you use the correct function name!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv(\"data/surveys.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 35549 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): species_id, sex\ndbl (7): record_id, month, day, year, plot_id, hindfoot_length, weight\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 9\n   record_id month   day  year plot_id species_id sex   hindfoot_length weight\n       <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>  <dbl>\n 1         1     7    16  1977       2 NL         M                  32     NA\n 2         2     7    16  1977       3 NL         M                  33     NA\n 3         3     7    16  1977       2 DM         F                  37     NA\n 4         4     7    16  1977       7 DM         M                  36     NA\n 5         5     7    16  1977       3 DM         M                  35     NA\n 6         6     7    16  1977       1 PF         M                  14     NA\n 7         7     7    16  1977       2 PE         F                  NA     NA\n 8         8     7    16  1977       1 DM         M                  37     NA\n 9         9     7    16  1977       1 DM         F                  34     NA\n10        10     7    16  1977       6 PF         F                  20     NA\n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\n\n\n## Python\n\nWe'll be using the `read_csv()` function from `pandas`, so make sure to load this module first.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n```\n:::\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\npd.read_csv(\"data/surveys.csv\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  month  day  year  ...  species_id  sex hindfoot_length  weight\n0              1      7   16  1977  ...          NL    M            32.0     NaN\n1              2      7   16  1977  ...          NL    M            33.0     NaN\n2              3      7   16  1977  ...          DM    F            37.0     NaN\n3              4      7   16  1977  ...          DM    M            36.0     NaN\n4              5      7   16  1977  ...          DM    M            35.0     NaN\n...          ...    ...  ...   ...  ...         ...  ...             ...     ...\n35544      35545     12   31  2002  ...          AH  NaN             NaN     NaN\n35545      35546     12   31  2002  ...          AH  NaN             NaN     NaN\n35546      35547     12   31  2002  ...          RM    F            15.0    14.0\n35547      35548     12   31  2002  ...          DO    M            36.0    51.0\n35548      35549     12   31  2002  ...         NaN  NaN             NaN     NaN\n\n[35549 rows x 9 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\nThis actually spits out quite a bit of information onto the screen! This is because we've not assigned the output of reading in the file to an object. As such, we can't work with the data yet. So, we'll have to fix this. I've done this on purpose, of course, to show that the command itself works.\n\nIt is always good practice to run commands like this without assigning things. That way you can double-check what gets stored into an object! We'll save the data into an object called `surveys`.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys <- read_csv(\"data/surveys.csv\")\n```\n:::\n\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys = pd.read_csv(\"data/surveys.csv\")\n```\n:::\n\n\n:::\n\n\n::: {.callout-note}\n## Reading in different types of data\n\nThere are many different functions available to read in various data formats. Below are some of the most common ones.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nThe `readr` package (part of `tidyverse`) has several functions to read data in different formats.\n\n* `read_csv()` - for comma separated values\n* `read_tsv()` - for tab separated values\n* `read_csv2()` - for CSV files exported from non-English spreadsheet programs that use the semi-colon ; as a separator and a comma , as the decimal place.\n* `read_table()` - to read data where each column is separated by one or more spaces.\n* `read_delim()` - a flexible function that allows you to define your own delimiter.\n\nThese functions have equivalents in base R (the default installation of R), which you can also use. They are very similarly named, for example: `read.csv()` and `read.table()` (notice the `.` instead of `_` in the function name). However, they have different default options, so pay attention to which one you use!\n\n## Python\n\nPython's `pd.read_csv()` function from `pandas` can read in many different types of (tabular) data. The way it recognises the different formats is by specifying the separator:\n\n* `pd.read_csv()` - for comma separated values\n* `pd.read_csv(file.tsv, sep = \"\\t\")` - for tab separated values\n* `pd.read_csv(file.csv, sep = \";\")` - for CSV files exported from non-English spreadsheet programs that use the semi-colon ; as a separator and a comma , as the decimal place.\n* `pd.read_table(file.txt)` - for general delimited text files and equivalent to `pd.read_csv()` with a default delimiter of `\\t` (tab)\n:::\n:::\n\n## Table structure\n\nNow that we've read in the `surveys` data set, we can start exploring it a bit more. It's quite a substantial data set, with 9 columns and 35549 rows.\n\n### Getting the first few rows\n\nA good starting point is to get a snippet of the data. We can use the `head()` function to get the first few rows of the table.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(surveys)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 9\n  record_id month   day  year plot_id species_id sex   hindfoot_length weight\n      <dbl> <dbl> <dbl> <dbl>   <dbl> <chr>      <chr>           <dbl>  <dbl>\n1         1     7    16  1977       2 NL         M                  32     NA\n2         2     7    16  1977       3 NL         M                  33     NA\n3         3     7    16  1977       2 DM         F                  37     NA\n4         4     7    16  1977       7 DM         M                  36     NA\n5         5     7    16  1977       3 DM         M                  35     NA\n6         6     7    16  1977       1 PF         M                  14     NA\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   record_id  month  day  year  plot_id species_id sex  hindfoot_length  weight\n0          1      7   16  1977        2         NL   M             32.0     NaN\n1          2      7   16  1977        3         NL   M             33.0     NaN\n2          3      7   16  1977        2         DM   F             37.0     NaN\n3          4      7   16  1977        7         DM   M             36.0     NaN\n4          5      7   16  1977        3         DM   M             35.0     NaN\n```\n\n\n:::\n:::\n\n\n:::\n\n### Understanding overall structure\n\nIt's also useful to have a bit of an overview of the overall structure of the table. This may seems trivial with smaller data sets, but the bigger the data set, the harder this can become!\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nIf we are just interested in finding out which columns we have, we can use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(surveys)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"record_id\"       \"month\"           \"day\"             \"year\"           \n[5] \"plot_id\"         \"species_id\"      \"sex\"             \"hindfoot_length\"\n[9] \"weight\"         \n```\n\n\n:::\n:::\n\n\nHowever, sometimes we want more detailed information. We can do this as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(surveys)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nspc_tbl_ [35,549 × 9] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ record_id      : num [1:35549] 1 2 3 4 5 6 7 8 9 10 ...\n $ month          : num [1:35549] 7 7 7 7 7 7 7 7 7 7 ...\n $ day            : num [1:35549] 16 16 16 16 16 16 16 16 16 16 ...\n $ year           : num [1:35549] 1977 1977 1977 1977 1977 ...\n $ plot_id        : num [1:35549] 2 3 2 7 3 1 2 1 1 6 ...\n $ species_id     : chr [1:35549] \"NL\" \"NL\" \"DM\" \"DM\" ...\n $ sex            : chr [1:35549] \"M\" \"M\" \"F\" \"M\" ...\n $ hindfoot_length: num [1:35549] 32 33 37 36 35 14 NA 37 34 20 ...\n $ weight         : num [1:35549] NA NA NA NA NA NA NA NA NA NA ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   record_id = col_double(),\n  ..   month = col_double(),\n  ..   day = col_double(),\n  ..   year = col_double(),\n  ..   plot_id = col_double(),\n  ..   species_id = col_character(),\n  ..   sex = col_character(),\n  ..   hindfoot_length = col_double(),\n  ..   weight = col_double()\n  .. )\n - attr(*, \"problems\")=<externalptr> \n```\n\n\n:::\n:::\n\n\n## Python\n\nIf we are just interested in finding out which columns we have, we can use:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIndex(['record_id', 'month', 'day', 'year', 'plot_id', 'species_id', 'sex',\n       'hindfoot_length', 'weight'],\n      dtype='object')\n```\n\n\n:::\n:::\n\n\nHowever, sometimes we want more detailed information. We can do this as follows:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 35549 entries, 0 to 35548\nData columns (total 9 columns):\n #   Column           Non-Null Count  Dtype  \n---  ------           --------------  -----  \n 0   record_id        35549 non-null  int64  \n 1   month            35549 non-null  int64  \n 2   day              35549 non-null  int64  \n 3   year             35549 non-null  int64  \n 4   plot_id          35549 non-null  int64  \n 5   species_id       34786 non-null  object \n 6   sex              33038 non-null  object \n 7   hindfoot_length  31438 non-null  float64\n 8   weight           32283 non-null  float64\ndtypes: float64(2), int64(5), object(2)\nmemory usage: 2.4+ MB\n```\n\n\n:::\n:::\n\n\n:::\n\nThis gives quite a bit of information, but overall it's quite straightforward: we can see the number of rows and column and we have information on the type of data that is contained in each column.\n\n\n### Summary values\n\nLastly, we can get some more information by creating some summary statistics.\n\nThis can be quite useful to quickly check if there are any strange values in your data. For example, you might have expectations on what is a plausible `weight` value, so if there are typos or errors (e.g. `weight = 0`), they will quickly show up.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(surveys)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   record_id         month             day             year         plot_id    \n Min.   :    1   Min.   : 1.000   Min.   : 1.00   Min.   :1977   Min.   : 1.0  \n 1st Qu.: 8888   1st Qu.: 4.000   1st Qu.: 9.00   1st Qu.:1984   1st Qu.: 5.0  \n Median :17775   Median : 6.000   Median :16.00   Median :1990   Median :11.0  \n Mean   :17775   Mean   : 6.478   Mean   :15.99   Mean   :1990   Mean   :11.4  \n 3rd Qu.:26662   3rd Qu.:10.000   3rd Qu.:23.00   3rd Qu.:1997   3rd Qu.:17.0  \n Max.   :35549   Max.   :12.000   Max.   :31.00   Max.   :2002   Max.   :24.0  \n                                                                               \n  species_id            sex            hindfoot_length     weight      \n Length:35549       Length:35549       Min.   : 2.00   Min.   :  4.00  \n Class :character   Class :character   1st Qu.:21.00   1st Qu.: 20.00  \n Mode  :character   Mode  :character   Median :32.00   Median : 37.00  \n                                       Mean   :29.29   Mean   : 42.67  \n                                       3rd Qu.:36.00   3rd Qu.: 48.00  \n                                       Max.   :70.00   Max.   :280.00  \n                                       NA's   :4111    NA's   :3266    \n```\n\n\n:::\n:::\n\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.describe()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          record_id         month  ...  hindfoot_length        weight\ncount  35549.000000  35549.000000  ...     31438.000000  32283.000000\nmean   17775.000000      6.477847  ...        29.287932     42.672428\nstd    10262.256696      3.396925  ...         9.564759     36.631259\nmin        1.000000      1.000000  ...         2.000000      4.000000\n25%     8888.000000      4.000000  ...        21.000000     20.000000\n50%    17775.000000      6.000000  ...        32.000000     37.000000\n75%    26662.000000     10.000000  ...        36.000000     48.000000\nmax    35549.000000     12.000000  ...        70.000000    280.000000\n\n[8 rows x 7 columns]\n```\n\n\n:::\n:::\n\n\n:::\n\n## Basic subsetting of data\n\nAlthough we'll go into more detail on how to select portions of a larger data set, we'll briefly cover some very basic subsetting techniques here - just to get us going.\n\n### Selecting columns\n\nWe saw that there are 9 different columns in our data set. One of them is `weight`, which holds weight measurements for different animal records.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can easily select an individual column using the `$` symbol. We type the name of the object and then specify which column we're interested in:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys$weight\n```\n:::\n\n\n\n## Python\n\nWe can easily select an individual column in a `pandas` DataFrame using the `.` notation. We type the name of the object and then specify which column we're interested in:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.weight\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0         NaN\n1         NaN\n2         NaN\n3         NaN\n4         NaN\n         ... \n35544     NaN\n35545     NaN\n35546    14.0\n35547    51.0\n35548     NaN\nName: weight, Length: 35549, dtype: float64\n```\n\n\n:::\n:::\n\n\n:::\n\n### Subsetting rows and columns {#subset_rc}\n\nWe can subset specific rows and columns using the square bracket `[ ]` notation. The way this is ordered is `[rows, columns]`.\n\nWe can divide the way we extract the data into two methods: based on their numerical index (index-based subsetting) or based on their label/name in the table (label-based subsetting).\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nHere, we are asking to return *all* the rows for the `species_id` column (its label). Note the comma before the `\"species_id\"` notation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys[ , \"species_id\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 1\n   species_id\n   <chr>     \n 1 NL        \n 2 NL        \n 3 DM        \n 4 DM        \n 5 DM        \n 6 PF        \n 7 PE        \n 8 DM        \n 9 DM        \n10 PF        \n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\nWe can also select a subset of rows for this column, for example the first 3 rows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys[1:3, \"species_id\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  species_id\n  <chr>     \n1 NL        \n2 NL        \n3 DM        \n```\n\n\n:::\n:::\n\n\n## Python\n\nHere, we are asking to return *all* the rows for the `species_id` column. We use the `loc` to use label-based indexing. Note the `: ,` before the `\"species_id\"` notation. This tells Python to get all the rows.\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.loc[: , \"species_id\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0         NL\n1         NL\n2         DM\n3         DM\n4         DM\n        ... \n35544     AH\n35545     AH\n35546     RM\n35547     DO\n35548    NaN\nName: species_id, Length: 35549, dtype: object\n```\n\n\n:::\n:::\n\n\nWe can also select a subset of rows for this column, for example the first 3 rows:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.loc[0:2, \"species_id\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0    NL\n1    NL\n2    DM\nName: species_id, dtype: object\n```\n\n\n:::\n:::\n\n\n:::\n\nAlternatively, we use index-based subsetting. Remember, this is based on the numerical position in the data set:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nLet's grab the first 3 rows, and columns 2 to 4:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys[1:3, 2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  month   day  year\n  <dbl> <dbl> <dbl>\n1     7    16  1977\n2     7    16  1977\n3     7    16  1977\n```\n\n\n:::\n:::\n\n\nor rows 10 to 15, and columns 2, 6 and 8:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys[10:15, c(2, 6, 8)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  month species_id hindfoot_length\n  <dbl> <chr>                <dbl>\n1     7 PF                      20\n2     7 DS                      53\n3     7 DM                      38\n4     7 DM                      35\n5     7 DM                      NA\n6     7 DM                      36\n```\n\n\n:::\n:::\n\n\n## Python\n\nLet's grab the first 3 rows, and columns 2 to 4:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.iloc[0:3, 1:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   month  day  year\n0      7   16  1977\n1      7   16  1977\n2      7   16  1977\n```\n\n\n:::\n:::\n\n\nor rows 10 to 15, and columns 2, 6 and 8:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys.iloc[9:15, [1, 5, 7]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    month species_id  hindfoot_length\n9       7         PF             20.0\n10      7         DS             53.0\n11      7         DM             38.0\n12      7         DM             35.0\n13      7         DM              NaN\n14      7         DM             36.0\n```\n\n\n:::\n:::\n\n\nRemember, Python's indexing is zero-based - so you have to be quite careful/accurate when you're after specific indexes! \n:::\n\n## Saving\n\nBefore we move on to the next section, we'll practice saving data to file. You might want to do this if you created new tables or subsetted your data and don't want to repeat that every single time you do your analysis.\n\n::: {.callout-warning}\nRemember: **never overwrite your raw data** but always keep this as a separate copy!\n:::\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nLet's create a practice data set to save, for example by taking the first 20 rows of our `surveys` data set and saving it in a file `surveys_snippet.csv`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys_snippet <- surveys[1:20, ]\n```\n:::\n\n\nWe can now save this. We do this with the `write_csv()` function. \nWe need to tell it which data set to save (this comes first) and then tell it with the `file =` argument *where* we want to save it. Here, we're saving it in our `data/` folder, as a file called `surveys_snippet.csv`. The file extension `.csv` is important, so don't forget to add it!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(surveys_snippet, file = \"data/surveys_snippet.csv\")\n```\n:::\n\n\n## Python\n\nLet's create a practice data set to save, for example by taking the first 20 rows of our `surveys` data set and saving it in a file `surveys_snippet.csv`.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys_snippet = surveys.iloc[0:20, :]\n```\n:::\n\n\nWe can now save this. We do this using `.to_csv`\n. \nWe need to tell it which data set to save (this comes first) and then tell it *where* we want to save it. Here, we're saving it in our `data/` folder, as a file called `surveys_snippet.csv`. The file extension `.csv` is important, so don't forget to add it!\n\nWe also include the `index = False` argument, so that the row numbers are not written to file.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys_snippet.to_csv(\"data/surveys_snippet.csv\", index = False)\n```\n:::\n\n\n:::\n\n::: {.callout-tip}\n## Data tip: quality control checks\n \nWhenever you read in your data, it's always good practice to do some quality checks. Here's a list of things to look out for:\n\n- Do you have the expected number of rows and columns?\n- Are your variables (columns) of the expected type? (e.g. numeric, character)\n- Is the range of numeric data within expected boundaries? For example: a column with months should go from 1 to 12; a column with human heights in cm should not have values below 30 or so; etc...\n- Do you have the expected number of unique values in categorical (character) variables?\n- Do you have missing values in the data, and were these imported correctly?\n \n::: {.panel-tabset group=\"language\"}\n## R\n\nIn R, you can answer many of these questions with the help of the following \nfunctions: `str()`, `summary()`, `length()`, `unique()`, `nrow()`, `ncol()`, `is.na()`.\n\nThere are also some R packages that can help making these diagnostic analysis easier. One good one is the `skimr` package (which has a good [introduction document](https://cran.r-project.org/web/packages/skimr/vignettes/skimr.html). \n\nIf you use the `skim()` function with your `data.frame` it will give you a tabular summary that will help you answer all these questions in one go!\n\n## Python\n\nIn Python, you can answer many of these questions with the help of the following functions, assuming a `pandas` DataFrame called `df` with column name `\"col\"` or a simple list `x`: `df.info()`, `df.describe()`, `df.shape[0]`, `df.shape[1]`, `len(df)`, `df[\"col\"].unique()`, `data[\"col\"].nunique()`, `x.isna()`, `x.isna().sum()`\n\n:::\n\n:::\n\n\n\n## Summary\n\n::: {.callout-tip}\n#### Key points\n\n- Tabular data is structured into columns (variables) and rows (observations)\n- Common data types include CSVs and TSVs - widely accessible formats where data are separated by commas or tabs\n- It is good practice to get insight into your data by examining the structure, creating summary statistics and checking for missing values\n- Basic subsetting allows us to quickly pull out certain variables or observations\n- Write modified tables to file, but always keep the original, raw, data intact!\n:::\n",
    "supporting": [
      "da2-03-tabular-data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}