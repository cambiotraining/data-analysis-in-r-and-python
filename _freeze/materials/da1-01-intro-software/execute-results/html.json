{
  "hash": "8bb7ff2e5c46a360254f566aee0702b8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Intro to software\" \n---\n\n::: {.callout-tip}\n#### Learning objectives\n\n- Get familiar with the programming language.\n- Get to know the interface software.\n:::\n\n## Context\n\n### Why learn programming?\n\nSimply put, programming allows you to **move away from point-and-click** activities. They might seem great because they're intuitive and relatively easy - until you want to redo an analysis after collecting more data. You then need to manually go through the whole process again.\n\nBy writing out the different steps of your analysis you're making all those 'clicks' explicit. The added benefit is that it forces you to think more about what steps you need to go through in your analysis, thereby making errors less likely!\n\nThis also very much improves the **reproducibility** of the analysis: after all, running the same code on the same data should also result in the same outcome. This is great when you're sharing your analysis with colleagues, but also great for your future self. Your brilliant approach might have made sense at the time, but who knows how much you still recall a year later...\nMore and more often funding bodies are (rightfully!) requiring you to include raw data and analysis pipelines when submitting a paper. So, you'll be ahead of the game.\n\n### Interacting with the programming language\n\nIn this course we're focusing on generic programming concepts, but we're illustrating them in two different languages: R and Python.\n\nIn both cases we don't *directly* type in commands in some kind of terminal window, but instead use an additional bit of software to make our programming experience a bit more user-friendly.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nFor R, the [RStudio](https://posit.co/products/open-source/rstudio/) software is a very popular choice - and one we'll be using here. It's free, open-source and well-supported. What more can you ask for?\n\n![The welcome screen of RStudio](images/rstudio-main.png){#fig-rstudio_main}\n\nIn the image above you can see that the window is divided into three main parts, each with various tabs. In clockwise order we have:\n\n1. **Console** / Terminal / Background jobs\n2. **Environment** / History / Connections / Tutorial\n3. **Files** / **Plots** / Packages / **Help** / Viewer / Presentation\n\nIn bold we've highlighted the tabs we'll be using most.\n\nIn the **Console** we can directly run code - more on that soon. The **Environment** shows any information that is stored in R's memory (empty in the figure above). The **Files** tab is a mini-browser; **Plots** shows you any plots that have been created and **Help** is where you can go for... well, help.\n\n## Python\n:::\n\n## Working directory\n\nA good way of staying organised is to keep all the files related to a given project together. Using that concept when programming is really helpful, because it makes it easier for the computer to find all the data, scripts and other information related to an analysis.\n\nWe often refer to this as the **working directory**. This simply is the starting point for the computer to look for stuff.\n\nBecause you easily accumulate a lot of files when analysing data, it's good to be organised. During this course we'll create a project folder called `data-analysis`, which we'll make our working directory.\n\nWithin this folder we'll have sub folders that allow us to further organise our data. We'll use the following structure:\n\n![The working directory structure of this course](images/working_directory.png){#fig-working_directory width=50%}\n\n| Folder | Description|\n|-----------|--------------------------------------------------------------|\n| data | Contains the data files we'll use in this course, for example `surveys.csv`. For your own analysis you might want to consider adding another folder within this to contain the `raw` data. It's good practice to always keep an untouched copy of your raw data. This helps with transparency and allows you analyse data differently in the future. Aim to keep your data cleaning and analyses programmatically. |\n| images | This folder will contain any images you might produce, for example for publications or data exploration. |\n| scripts | Here we can store any scripts we create. Here it's also good to be structured and organised, something we cover a bit more in @sec-splitting_code. |\n| ... | The opportunities are endless. You can add folders for documents, presentations, etc. How you do things matters less than being *consistent*! |\n\nAll the files in the working directory can be referenced using **relative paths**. This allows you to move you working directory across your computer - or to other computers - without breaking any of the links within your scripts.\n\n::: {.callout-important}\n## Relative versus absolute paths\n\nRelative paths are relative to a certain location on your computer. Absolute paths start from the absolute start of your hard drive. This is easiest illustrated with an example:\n\n![Relative vs absolute paths](images/working_directory_example.png){#fig-working_directory_example}\n\n:::\n\n### Creating a working directory\n\nBefore we start writing any code we'll set up our working environment properly. To do this, we'll create our `data-analysis` working directory, with all its sub folders.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nThe easiest way to set up a working directory in R is to create an **R-project**. This is simply a folder on your computer with a shortcut in it (ending in `.RProj`). When you double-click on the shortcut, it opens RStudio and sets the working directory to that particular folder. \n\nTo create an \"R Project\":\n\n::: {.carousel data-caption=\"Setting up a new working directory (click to toggle).\"}\n\n![](images/wd-setup-01.png)\n![](images/wd-setup-02.png)\n![](images/wd-setup-03.png)\n![](images/wd-setup-04.png)\n:::\n\n1. Start RStudio.\n2. Under the `File` menu, click on `New Project`. Choose `New Directory`, then\n  `New Project`.\n3. Enter a name for this new folder (or \"directory\"), and choose a convenient\n  location for it. This will be your **working directory** for the rest of the\n  day (*e.g.,* `~/data-analysis`).\n4. Click on `Create Project`.\n5. Tick `Open in new session` to ensure RStudio starts afresh.\n\nR will show you your current working directory in the `Files` pane. Alternatively, you can get it by typing in and running the `getwd()` command.\n\n## Python\n\n:::\n\n::: {.callout-important}\nComplete [setting up a working directory](#ex-createwd) before proceeding.\n:::\n\n## Working with R or Python\n\nThe basis of programming is that we create or *code* instructions for the computer to follow. Next, we tell the computer to follow the instructions by *executing* or *running* those instructions.\n\n### Scripts versus console\n\nThere are two main ways of interacting with the language: by using the console or by using script files (plain text files that contain your code). The console is the place where commands can be typed and executed immediately by the computer. It is also where the results will be shown for commands that have been executed. However, no record is kept and any information is lost once the session is closed.\n\nInstead, we uses scripts to write all the commands. That way there is a complete record of what we did, and anyone (including our future selves!) can easily replicate the results on their computer.\n\n| Console/terminal <i class=\"fa fa-terminal fa-1x\"></i>| Script <i class=\"fa-regular fa-file-lines fa-1x\"></i>|\n|-------------------------------------|-------------------------------------|\n| runs code directly | in essence, a text file |\n| interactive | needs to be told to run |\n| no record | records actions |\n| difficult to trace progress | transparent workflow |\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can type commands directly in the **Console** pane and press {{< kbd Enter >}}. \n\nRStudio also allows you to execute commands directly from the script editor by using the {{< kbd Control >}} + {{< kbd Enter >}} shortcut (on Macs, {{< kbd mac=Command >}} + {{< kbd mac=Return >}} will work, too). The command on the current line in the script (indicated by the cursor) or all of the commands in the currently selected text will be sent to the console and executed when you press {{< kbd Control >}} + {{< kbd Enter >}}. You can find other keyboard shortcuts in this [RStudio cheatsheet about the RStudio IDE (PDF)](https://rstudio.github.io/cheatsheets/rstudio-ide.pdf).\n\n::: {.callout-warning}\n## The R prompt\n\nIf R is ready to accept commands, the R console shows a `>` prompt. If it\nreceives a command (by typing, copy-pasting or sent from the script editor using\n{{< kbd Control >}} + {{< kbd Enter >}}), R will try to execute it, and when\nready, will show the results and come back with a new `>` prompt to wait for new\ncommands.\n\nIf R is still waiting for you to enter more data because it isn't complete yet,\nthe console will show a `+` prompt. It means that you haven't finished entering\na complete command. This is because you have not 'closed' a parenthesis or\nquotation, i.e. you don't have the same number of left-parentheses as\nright-parentheses, or the same number of opening and closing quotation marks.\nWhen this happens, and you thought you finished typing your command, click\ninside the console window and press {{< kbd Escape >}}. This will cancel the incomplete command and return you to the `>` prompt.\n:::\n\n## Python\n:::\n\n## Running code {#running-code}\n\nThe simplest way of using a programming language is to use it interactively. We can do this by typing directly into the console / terminal.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nFor example, you can use R as a glorified calculator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3 + 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n\n```{.r .cell-code}\n12 / 7\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.714286\n```\n\n\n:::\n:::\n\n\n## Python\n\nFor example, you can use Python as a glorified calculator:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n3 + 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8\n```\n\n\n:::\n\n```{.python .cell-code}\n12 / 7\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1.7142857142857142\n```\n\n\n:::\n:::\n\n\n:::\n\nRunning code like this directly in the console is generally not a good idea, because then we can't keep track of what we are doing. So, we first need to create a script to save our code in. Then, we can then play around. Let's focus on that next.\n\n### Splitting code {#sec-splitting_code}\n\nAs your analysis grows, so does your code. So,often we want to split analyses into multiple scripts, for example:\n\n* `01_preprocessing` may contain data cleaning steps\n* `02_exploration` may contain exploratory plots of your data\n* `03_analysis` could contain (statistical) analyses of your data\n* `04_figures` could contain code for figures, ready for publication\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nEach of these files could be hundreds of lines long. So, keeping track of your code makes sense. We can do that with **code headings**, which use the `# heading ----` syntax. You can even add different heading levels, by increasing the number of `#` at the start.\n\nThis creates a little table of contents in the bottom-left corner of the script pane:\n\n![Code headings](images/rstudio-codeheadings.png)\n\n## Python\n\n:::\n\n### Comments in code\n\nIt's always a good idea to add explanations to your code. We can do that with the hash tag `#` symbol, for example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This code calculates the sum of two numbers\n1 + 9\n```\n:::\n\n\n\nIt's always a good idea to add lots of comments to your code. What makes sense to you in that moment, might not a week later. Similarly, when sharing code with colleagues and collaborators, it's always good to be as clear as possible.\n\n::: {.callout-important}\n## Complete before proceeding\nPlease complete the exercises to [create a script](#ex-createscript) and trial [running code](#ex-runningcode).\n:::\n\n## Functions and their arguments\n\nFunctions are \"canned scripts\" that automate more complicated sets of commands\nincluding operations assignments, etc. Many functions are predefined, or can be\nmade available by importing *packages* (more on that later). A function\nusually takes one or more inputs called *arguments*. Functions often (but not\nalways) return a *value*. A typical example would be the function `sqrt()`. The\ninput (the argument) must be a number, and the return value (in fact, the\noutput) is the square root of that number.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(9)\n```\n:::\n\n\n## Python\n\nThe `sqrt()` function is not available by default, but is stored in the `math` module. Before we can use it, we need to load this module:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport math\n```\n:::\n\n\nNext, we can use the `sqrt()` function, specifying that it comes from the `math`module. We separate the two with a full-stop (`.`):\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmath.sqrt(9)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3.0\n```\n\n\n:::\n:::\n\n\n:::\n\nHere, the value `9` is given to the `sqrt()` function. This function\ncalculates the square root, and returns the value. This function is very simple, because it takes just one argument.\n\nThe return 'value' of a function need not be numerical (like that of `sqrt()`),\nand it also does not need to be a single item: it can be a set of things, or\neven a data set. We'll see that when we read data files.\n\n\n### Arguments\n\nArguments allow you to control the behaviour of a function. They can be anything, not only numbers or file names. Exactly what each argument means differs per function and can be looked up in the documentation. Some functions take arguments which may either be specified by the user, or, if left out, take on a *default* value: these are called *options*.\n\nOptions are typically used to alter the way the\nfunction operates, such as if it should ignore missing values, or what symbol to\nuse in a plot.  However, if you want something specific, you can specify a value\nof your choice which will be used instead of the default.\n\nLet's try a function that can take multiple arguments: `round()`.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(3.14159)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nround(3.14159)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3\n```\n\n\n:::\n:::\n\n\n:::\n\nHere, we've called `round()` with just one argument, `3.14159`, and it has\nreturned the value `3`.  That's because the default is to round to the nearest\nwhole number. If we want more digits we can see how to do that by getting\ninformation about the `round()` function.  \n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can use `args(round)` to find what arguments it takes, or look at the help for this function using `?round`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(round)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, digits = 0, ...) \nNULL\n```\n\n\n:::\n:::\n\n\nWe see that if we want a different number of digits, we can\ntype `digits = 2` or however many we want. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(x = 3.14159, digits = 2)\n```\n:::\n\n\nIf you provide the arguments in the exact same order as they are defined you\ndon't have to name them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(3.14159, 2)\n```\n:::\n\n\nAnd if you do name the arguments, you can switch their order:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(digits = 2, x = 3.14159)\n```\n:::\n\n\n## Python\nWe can use `help(round)` to find what arguments it takes.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nhelp(round)\n```\n:::\n\n\nWe see that if we want a different number of digits, we can\ntype `ndigits = 2` or however many we want. For example:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nround(3.14159, ndigits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3.14\n```\n\n\n:::\n:::\n\n\nIf you provide the arguments in the exact same order as they are defined you\ndon't have to name them:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nround(3.14159, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3.14\n```\n\n\n:::\n:::\n\n\nPython still expects the arguments in the correct order, so this gives an error:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nround(ndigits = 2, 3.14159)\n```\n:::\n\n:::\n\nIt's good practice be explicit about the names of the arguments. That way you can avoid confusion later on when looking back at your code or when sharing your code.\n\n\n## Adding functionality using packages\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nAdditional packages can be installed to extend the functionality of R. Most packages are available in a central repository called CRAN and can be installed from within R using the `install.packages()` function.\n\nFor example, to install (or update) the `tidyverse` package, you would run the following command on the console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n:::\n\n\nBecause the install process accesses the CRAN repository, you will need an Internet connection to install packages.\n\nAfter this, you can then load the package to use it in your analysis. You load packages using the `library()` command (note the lack of quotation marks):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nThere are other repositories available. A very popular one is the Bioconductor project, which contains thousands of packages for bioinformatics applications. These use a different installation command, but the instructions are always given in each packageâ€™s page.\n\n## Python\n\nAdditional packages can be installed to extend the functionality of Python. In the next section we'll need some functionality from the `numpy` package, so we'll install it here. We can do this directly from within JupyterLab:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n!mamba install -c conda-forge numpy -y\n```\n:::\n\n\n:::\n\nThis uses the `mamba` package manager to install `numpy`. It gets the information from the `conda-forge` channel and the `-y` simply auto-confirms the installation.\n\n\n## Exercises\n\n:::{.callout-exercise #ex-createwd}\n#### Creating a working directory\n{{< level 1 >}}\n\nCreate a working directory called `data-analysis`. When you've done this, add the following sub folders:\n\n* `data`\n* `scripts`\n* `images`\n\n**Note**: programming languages are case-sensitive, so `data` is not treated the same way as `Data`.\n:::\n\n:::{.callout-exercise #ex-createscript}\n#### Creating a script\n{{< level 1 >}}\n\nCreate a script and save it as `session_01` in the `scripts` folder within your working directory.\n\n:::{.callout-hint}\nRemember, you will need to add an extension to the file. This is `.R` for R scripts or `.py` for Python ones.\n:::\n:::\n\n:::{.callout-exercise #ex-runningcode}\n#### Running code\n{{< level 1 >}}\n\nIn your new script `session_01`, run some mathematical operations, such as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n8 * 4\n6 - 9\n```\n:::\n\n\n:::{.callout-hint}\nRemember, you run the code using <kbd>Ctrl</kbd> + <kbd>Enter</kbd> (or <kbd>Command</kbd> + <kbd>Enter</kbd> on Mac).\n:::\n\n:::\n\n## Summary\n\n::: {.callout-tip}\n#### Key points\n\n- \n:::\n",
    "supporting": [
      "da1-01-intro-software_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}