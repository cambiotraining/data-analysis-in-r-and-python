{
  "hash": "da9e3fde375a734d00705bd2a3aa16a1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Chaining operations\n---\n\n::: {.callout-tip}\n#### Learning objectives\n\n- \n:::\n\n## Context\n\nIn the section above we performed several operations on a single data set. Often there is a sequence to this, where the output of one operation gets fed into the next. We can simplify this by chaining commands.\n\n## Section setup {#setup_chaining_operations}\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe'll continue this section with the script named `06-chaining-operations.R`. If needed, add the following code to the top of your script and run it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A collection of R packages designed for data science\nlibrary(tidyverse)\n\nsurveys <- read_csv(\"data/surveys.csv\")\n```\n:::\n\n\n## Python\n\nWe'll continue this section with the script named `06-chaining-operations.py`.\n\nIf needed, add the following code to the top of your script and run it.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# A Python data analysis and manipulation tool\nimport pandas as pd\n\n# Python equivalent of `ggplot2`\nfrom plotnine import *\n\nsurveys = pd.read_csv(\"data/surveys.csv\")\n```\n:::\n\n\n:::\n:::\n\n## Pipes\n\nSo far, we've used single operations when we were manipulating our data. For example, we can select columns with:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(surveys, record_id, hindfoot_length)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 2\n   record_id hindfoot_length\n       <dbl>           <dbl>\n 1         1              32\n 2         2              33\n 3         3              37\n 4         4              36\n 5         5              35\n 6         6              14\n 7         7              NA\n 8         8              37\n 9         9              34\n10        10              20\n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\nLet's say we wanted combine that with creating a new column, for example hindfoot length in centimeters.\n\nWe would have to do the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# grab the relevant columns and store in a new object\nsubset_surveys <- select(surveys, record_id, hindfoot_length)\n\n# create the new column\nmutate(subset_surveys, hindfoot_length_cm = hindfoot_length / 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 3\n   record_id hindfoot_length hindfoot_length_cm\n       <dbl>           <dbl>              <dbl>\n 1         1              32                3.2\n 2         2              33                3.3\n 3         3              37                3.7\n 4         4              36                3.6\n 5         5              35                3.5\n 6         6              14                1.4\n 7         7              NA               NA  \n 8         8              37                3.7\n 9         9              34                3.4\n10        10              20                2  \n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\nWe had to create a new *object* (here, called `subset_surveys`) to store the intermediate data we were interested in, and then continue with creating the new column.\n\nThis clutters up your computer's memory rather quickly when dealing with lots of data. A much better way is that we **pipe** one after the other. To do this, we *start with the data* and use a pipe symbol (`|>` or `%>%`) as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys |> \n  select(record_id, hindfoot_length) |>\n  mutate(hindfoot_length_cm = hindfoot_length / 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 35,549 × 3\n   record_id hindfoot_length hindfoot_length_cm\n       <dbl>           <dbl>              <dbl>\n 1         1              32                3.2\n 2         2              33                3.3\n 3         3              37                3.7\n 4         4              36                3.6\n 5         5              35                3.5\n 6         6              14                1.4\n 7         7              NA               NA  \n 8         8              37                3.7\n 9         9              34                3.4\n10        10              20                2  \n# ℹ 35,539 more rows\n```\n\n\n:::\n:::\n\n\nAn easy way of remembering what the pipe does is to replace (in your head) the pipe symbol with the phrase \"and then...\".\n\nSo, we `select()` the `record_id` and `hindfoot_length` columns *and then* use mutate to create a new column called `hindfoot_length_cm`.\n\n::: {.callout-note}\n## Which pipe symbol do I use?\n\nYou'll find that people use two pipe symbols quite interchangeably in R: the `|>` pipe (native, built-in R) and `%>%` from the `magrittr` package.\n\nThe native, built-in pipe is a rather new addition, since version 4.1. It is slightly different in its behaviour than the `%>%` pipe (if you want to know more, see [here](https://ivelasq.rbind.io/blog/understanding-the-r-pipe/#:~:text=A%20while%20back%2C%20I%20wrote,available%20since%20R%20version%204.1.)), but for most purposes they work the same.\n\nWe tend to use the native, built-in pipe throughout the materials. But the `magrittr` pipe works just as well! You can change your preference in RStudio by going to `Tools > Global options > Code` and changing the tickbox enabling/disabling the native pipe operator.\n\n:::\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsurveys[[\"record_id\", \"hindfoot_length\"]].copy()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  hindfoot_length\n0              1             32.0\n1              2             33.0\n2              3             37.0\n3              4             36.0\n4              5             35.0\n...          ...              ...\n35544      35545              NaN\n35545      35546              NaN\n35546      35547             15.0\n35547      35548             36.0\n35548      35549              NaN\n\n[35549 rows x 2 columns]\n```\n\n\n:::\n:::\n\n\nLet's say we wanted combine that with creating a new column, for example hindfoot length in centimeters.\n\nWe would have to do the following:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# select the required columns and store in a new data set\nselected = surveys[[\"record_id\", \"hindfoot_length\"]].copy()\n\n# take the new data set and calculate the new column\nselected[\"hindfoot_length_cm\"] = selected[\"hindfoot_length\"] / 10\n```\n:::\n\n\nWe had to create a new *object* (here, called `subset_surveys`) to store the intermediate data we were interested in, and then continue with creating the new column.\n\nThis clutters up your computer's memory rather quickly when dealing with lots of data. So, it'd be good if we could **pipe** these commands through, like we can do in R.\n\nBut, a bit of sad news here. Python does not really have an equivalent to pipes in R. You can somewhat emulate it with a non-intuitive set of operations like this:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n(surveys\n  [[\"record_id\", \"hindfoot_length\"]]\n  .assign(hindfoot_length_cm=lambda df: df[\"hindfoot_length\"] / 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       record_id  hindfoot_length  hindfoot_length_cm\n0              1             32.0                 3.2\n1              2             33.0                 3.3\n2              3             37.0                 3.7\n3              4             36.0                 3.6\n4              5             35.0                 3.5\n...          ...              ...                 ...\n35544      35545              NaN                 NaN\n35545      35546              NaN                 NaN\n35546      35547             15.0                 1.5\n35547      35548             36.0                 3.6\n35548      35549              NaN                 NaN\n\n[35549 rows x 3 columns]\n```\n\n\n:::\n:::\n\n\nHere, we do the following:\n\n* `surveys[[\"record_id\", \"hindfoot_length\"]]` selects the columns you want\n* `.assign(...)` then creates a new column\n* `lambda df` tells `pandas` to compute the new column using the current data frame in the chain\n\nBut I guess you'll agree that this is not that much easier to read. There are some `dplyr`-style implementations in Python, that also include a pipe. One is [siuba](https://github.com/machow/siuba) but it does not seem to be actively maintained. Another one is [dfply](https://github.com/kieferk/dfply), which has not been updated for 7 years and counting...\n:::\n\n\n## Summary\n\n::: {.callout-tip}\n#### Key points\n\n- \n:::\n",
    "supporting": [
      "06-chaining-operations_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}